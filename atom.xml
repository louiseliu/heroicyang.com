<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Heroic Yang's Blog]]></title>
  <subtitle><![CDATA[Front-Ender, love javascript and node.]]></subtitle>
  <link href="http://heroicyang.com/atom.xml" rel="self"/>
  <link href="http://heroicyang.com"/>
  <updated>2013-06-17T14:48:57.342Z</updated>
  <id>http://heroicyang.com/</id>
  <author>
    <name><![CDATA[Heroic Yang]]></name>
    <email><![CDATA[me@heroicyang.com]]></email>
  </author>
  <generator uri="http://zespia.tw/hexo">Hexo</generator>
  <entry>
    <title type="html"><![CDATA[JavaScript中创建类的方式]]></title>
    <link href="http://heroicyang.com/2012/08/19/create-class-in-javascript/"/>
    <id>http://heroicyang.com/2012/08/19/create-class-in-javascript/</id>
    <published>2012-08-18T17:05:00.000Z</published>
    <updated>2013-05-24T15:17:10.000Z</updated>
    <content type="html"><![CDATA[<p>现在<code>JavaScript</code>这门技术已经到了一个引爆点，一年前我对它的了解都只停留在肤浅的网页客户端脚本语言，只会简单的玩玩<code>jQuery</code>和<code>ExtJs</code>，其实都算不上开发者，而是一个<code>JavaScript</code>用户。但今年的目标是做一个合格的前端攻城湿，所以恶补是必须的。  </p>
<p>在<code>JavaScript</code>中是其实不存在所谓“类”的概念，因为它并不是面向对象的语言。在面向对象中，一个最常见的说法就是：“类”是“对象”的模板，基本上都是采用语言内置的<code>Class</code>或<code>class</code>关键字来定义“类”。而<code>JavaScript</code>不存在这个概念，所以也没有提供类似的关键字（虽然<code>class</code>是<code>JavaScript</code>的关键字，但是至今都没有实现，只是被保留而已）。  </p>
<p>因此，在<code>JavaScript</code>中创建类就唯有使用模拟的方式，而模拟的手法多种多样，何时采用何种方式最合适，需视情况而定。以下就记录下常见的几种模式。
<a name="more"></a></p>
<h3>一.工厂模式</h3>
<p>工厂方法是设计模式中非常基础的，也被广泛用于面向对象编程中。而在<code>JavaScript</code>中，通过工厂方法即能模拟出类的行为。  </p>
<p><figure class="highlight lang-javascript"><pre><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span><span class="params">(name, sex, …)</span> {</span>
  <span class="keyword">var</span> obj = {};
  obj.name = name;
  obj.sex = sex;
  …
  obj.getName = <span class="keyword">function</span>() {
    <span class="keyword">return</span> <span class="keyword">this</span>.name;
  };
  <span class="keyword">return</span> obj;
}
<span class="keyword">var</span> personA = createPerson(<span class="string">'heroicYang'</span>, <span class="string">'male'</span>);
<span class="keyword">var</span> personB = createPerosn(<span class="string">'路人甲'</span>, <span class="string">'male'</span>);
</pre></figure><br>通过这样类似的工厂方法，就可以创建出多个相似的对象了，但是这样的方式其抽象度极低。面向对象编程中，对象是可以检测出类型的，但是采用上面这种方式，是没有办法进行对象类型识别的。</p>
<h3>二.构造函数模式</h3>
<p>其实，这应该是很常见的模式了，很多书上基本上一来就是讲这个的，更狠点的可能就只讲这个…</p>
<p><figure class="highlight lang-javascript"><pre><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name, sex)</span> {</span>
  <span class="keyword">this</span>.name = name;
  <span class="keyword">this</span>.sex = sex;
  …
  <span class="keyword">this</span>.getName = <span class="keyword">function</span>() {
    <span class="keyword">return</span> <span class="keyword">this</span>.name;
  }
}
<span class="keyword">var</span> personA = <span class="keyword">new</span> Person(<span class="string">'heroic'</span>, <span class="string">'male'</span>);
<span class="keyword">var</span> personB = <span class="keyword">new</span> Person(<span class="string">'路人甲'</span>, <span class="string">'male'</span>);
</pre></figure><br>这种模拟类方式的特点就是:</p>
<ol>
<li>没有显示的创建对象   </li>
<li>直接将属性和方法赋给了<code>this</code>对象    </li>
<li>没有<code>return</code>字句</li>
</ol>
<p>在使用这种方式时，创建对象则必须使用<code>new</code>关键字。当然，好处就是完全解决了对象类型识别问题。</p>
<h3>三.原型模式</h3>
<p>原型应该是<code>JavaScript</code>中一个很有意思，当然也是很有用的一个概念了。接下来用原型模式来模拟类。</p>
<p><figure class="highlight lang-javascript"><pre>  
<span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">()</span> {</span>}
Person.prototype = {
  name: <span class="literal">null</span>,
  sex: <span class="literal">null</span>,
  getName: <span class="keyword">function</span>() {
    <span class="keyword">return</span> <span class="keyword">this</span>.name;
  }
};
<span class="keyword">var</span> personA = <span class="keyword">new</span> Person;
personA.name = <span class="string">'heroic'</span>;
personA.sex = <span class="string">'male'</span>;
<span class="keyword">var</span> personB = <span class="keyword">new</span> Person;
personB.name = <span class="string">'路人甲'</span>;
personB.sex = <span class="string">'male'</span>;
</pre></figure></p>
<h3>四.组合使用构造函数和原型模式</h3>
<p>由于只用原型模式的话，会带来一些问题，所以常规情况下，都是采用组合构造函数和原型模式来创建类，这也是使用率最高的一种方式。</p>
<p><figure class="highlight lang-javascript"><pre><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name, sex)</span> {</span>
  <span class="keyword">this</span>.name = name;
  <span class="keyword">this</span>.sex = sex;
  …
}
Person.prototype.getName = <span class="keyword">function</span>() {
  <span class="keyword">return</span> <span class="keyword">this</span>.name;
};
…
<span class="keyword">var</span> personA = <span class="keyword">new</span> Person(<span class="string">'heroic'</span>, <span class="string">'male'</span>);
<span class="keyword">var</span> personB = <span class="keyword">new</span> Person(<span class="string">'路人甲'</span>, <span class="string">'male'</span>);
personA.getName(); <span class="comment">//"heroic"</span>
personB.getName(); <span class="comment">//"路人甲"</span>
</pre></figure></p>
<h3>五.寄生构造函数模式</h3>
<p>这种模式和工厂模式非常相似。</p>
<p><figure class="highlight lang-javascript"><pre><span class="function"><span class="keyword">function</span> <span class="title">SpecialArray</span><span class="params">()</span> {</span>
  <span class="keyword">var</span> values = <span class="keyword">new</span> Array();
  values.push.apply(values, arguments);
    
  values.toPipString = <span class="keyword">function</span>() {
    <span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">'|'</span>);
  }
  <span class="keyword">return</span> values;
}
<span class="keyword">var</span> test = <span class="keyword">new</span> SpecialArray(<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>);
test.toPipString(); <span class="comment">// "1|2|3"</span>
</pre></figure><br>这种模式主要用来扩展一些对象的行为，而又不会对这个对象造成污染。当然，上面的代码也是可以直接为<code>Array.prototype</code>原型对象添加一个<code>toPipString()</code>方法来完成的，但是这样就造成了对<code>JavaScript</code>原生对象的污染。</p>
]]></content>
    <category scheme="http://heroicyang.com/tags/javascript/" term="javascript"/>
    <category scheme="http://heroicyang.com/tags/javascript-class/" term="javascript class"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[Backbone之旅：前端MVC架构初体验（上）]]></title>
    <link href="http://heroicyang.com/2012/08/08/to-backbone-tutorial-1/"/>
    <id>http://heroicyang.com/2012/08/08/to-backbone-tutorial-1/</id>
    <published>2012-08-07T16:48:00.000Z</published>
    <updated>2013-05-24T15:17:16.000Z</updated>
    <content type="html"><![CDATA[<p>最近一段时间来，才算是真正的开始深入学习<code>JavaScript</code>，收获颇丰。也首次领略了前端<code>MVC</code>架构的风采，现在前端<code>MVC</code>的类库和框架越来越多，在经过初步的评估之后，决定先学习备受推崇的<code>Backbone</code>。 </p>
<p>以前自己做的一些<code>Web</code>应用，基本上都是按照非常传统的方式：1.服务器端渲染模板；2.利用<code>jQuery</code>的<code>ajax</code>进行异步数据交换。所以首次接触前端架构类的东西，难免有点无从下手。经过几天的奋战，以及参阅国外大牛们的各种<code>Tutorial</code>之后，终于拨开迷雾，缕了些头绪，自己也试着从传统的方式过渡（重构）出了所谓的架构性的代码。  </p>
<p>整个重构的过程让我受益良多，所以决定再认真的记录一遍，加深自己的印象，也再确认一遍自己是否真的搞明白了，文章应该会比较长。  </p>
<a name="more"></a>

<p>首先，先上一段所谓的传统式的代码。</p>
<p><figure class="highlight lang-javascript"><pre>$(<span class="keyword">function</span>(){
  $(<span class="string">'#new-todo form'</span>).submit(<span class="keyword">function</span>(e){
    e.preventDefault();
    <span class="keyword">var</span> that = <span class="keyword">this</span>;

    $.ajax({
      url: <span class="string">'/add'</span>,
      type: <span class="string">'POST'</span>,
      dataType: <span class="string">'json'</span>,
      data: { todoContent: $(<span class="keyword">this</span>).find(<span class="string">'textarea'</span>).val() },
      success: <span class="keyword">function</span>(data){
        $(<span class="string">'#todo-list ul'</span>).append(<span class="string">'&lt;li&gt;'</span> + data.todoContent + <span class="string">'&lt;/li&gt;'</span>);
        $(that).find(<span class="string">'textarea'</span>).val(<span class="string">''</span>);
      }
    });
  });
});
</pre></figure><br>另外，也上一张关于这篇文章中涉及到的<code>HTML</code>结构图，方便参照。由于文章稍长，我想如果直接在这里插图的话会影响阅读，所以就只给出<a href="http://img.heroicyang.com/to-backbone-tutorial.png">图片链接</a>了。 </p>
<p>上面的一段代码我想应该都是大家非常熟悉的做法，因为我是一个伪前端攻城湿，所以我以前的代码中无不充斥着类似的、一堆一堆这样的代码。看上去貌似挺好的啊，也没啥问题，程序跑得倍儿棒。但是就这么短短的一段代码，它可干了不少事情：监听页面事件、用户事件、网络事件，接收用户的输入、执行网络的I/O、解析服务端返回的数据、动态生成<code>HTML</code>结构，可谓是包罗万象啊，就这么短短的一段代码就解释了整个<code>Web</code>应用程序的本质。  </p>
<p>所以即便是这么一个小小的应用，逻辑和架构上都已经臃肿了，完全违反了咱们软件开发中的“单一职责原则”。如果是一个大应用，那估计就如乱麻------剪不断理还乱了。所以，改变迫在眉睫。 </p>
<p>确实咱的要求也不高，如果把它搞成这样，其实咱就满足了：</p>
<ol>
<li>在<code>$(document).ready</code>当中只保留一些应用程序的初始化代码即可，即应用的启动程序。  </li>
<li>干掉乱如麻的逻辑，使得其符合咱们的“单一职责原则”，方便测试。  </li>
<li>减小<code>ajax</code>和<code>DOM</code>的耦合，其实也算是第2条。  </li>
</ol>
<p>OK，动手。按照最基本的重构方式，咱先把<code>ajax</code>分离到一个方法里面去。  </p>
<p><figure class="highlight lang-javascript"><pre><span class="keyword">var</span> addTodo = <span class="keyword">function</span>(){
  $.ajax({
    url: <span class="string">'/add'</span>,
    type: <span class="string">'POST'</span>,
    dataType: <span class="string">'json'</span>,
    data: { todoContent: $(<span class="string">'#new-todo'</span>).find(<span class="string">'textarea'</span>).val() },
    success: <span class="keyword">function</span>(data){
      $(<span class="string">'#todo-list ul'</span>).append(<span class="string">'&lt;li&gt;'</span> + data.todoContent + <span class="string">'&lt;/li&gt;'</span>);
      $(<span class="string">'#new-todo'</span>).find(<span class="string">'textarea'</span>).val(<span class="string">''</span>);
    }
  });
};

$(<span class="keyword">function</span>(){
  $(<span class="string">'#new-todo form'</span>).submit(<span class="keyword">function</span>(e){
    e.preventDefault();
    
    addTodo();
  });
});
</pre></figure><br>但是，在<code>ajax</code>所在的方法中，<code>data</code>和<code>success</code>属性仍然保留了对<code>DOM</code>的依赖，于是接下来将其调整为函数的参数来传递。  </p>
<p><figure class="highlight lang-javascript"><pre><span class="keyword">var</span> addTodo = <span class="keyword">function</span>(options){
  $.ajax({
    url: <span class="string">'/add'</span>,
    type: <span class="string">'POST'</span>,
    dataType: <span class="string">'json'</span>,
    data: { todoContent: options.todoContent },
    success: options.success
  });
};

$(<span class="keyword">function</span>(){
  $(<span class="string">'#new-todo form'</span>).submit(<span class="keyword">function</span>(e){
    e.preventDefault();
    
    addTodo({
      todoContent: $(<span class="string">'#new-todo'</span>).find(<span class="string">'textarea'</span>).val(),
      success: <span class="keyword">function</span>(data){
        $(<span class="string">'#todo-list ul'</span>).append(<span class="string">'&lt;li&gt;'</span> + data.todoContent + <span class="string">'&lt;/li&gt;'</span>);
        $(<span class="string">'#new-todo'</span>).find(<span class="string">'textarea'</span>).val(<span class="string">''</span>);
      }
    });
  });
});
</pre></figure><br>好像OK了，不过此时<code>addTodo()</code>方法暴露在全局环境内，任何人都可以呼之欲来。我可不想当屌丝，作为一个富有上进心的、想成为一个合格前端攻城湿的我，还是给<code>addTodo()</code>方法加个命名空间吧。  </p>
<p><figure class="highlight lang-javascript"><pre><span class="keyword">var</span> TodoList = <span class="keyword">function</span>(){};

TodoList.prototype.add = <span class="keyword">function</span>(options){
  $.ajax({
    url: <span class="string">'/add'</span>,
    type: <span class="string">'POST'</span>,
    dataType: <span class="string">'json'</span>,
    data: { todoContent: options.todoContent },
    success: options.success
  });
};

$(<span class="keyword">function</span>(){
  <span class="keyword">var</span> todoList = <span class="keyword">new</span> TodoList();

  $(<span class="string">'#new-todo form'</span>).submit(<span class="keyword">function</span>(e){
    e.preventDefault();
    
    todoList.add({
      todoContent: $(<span class="string">'#new-todo'</span>).find(<span class="string">'textarea'</span>).val(),
      success: <span class="keyword">function</span>(data){
        $(<span class="string">'#todo-list ul'</span>).append(<span class="string">'&lt;li&gt;'</span> + data.todoContent + <span class="string">'&lt;/li&gt;'</span>);
        $(<span class="string">'#new-todo'</span>).find(<span class="string">'textarea'</span>).val(<span class="string">''</span>);
      }
    });
  });
});
</pre></figure><br>现在<code>submit</code>事件只依赖一个<code>todoList</code>变量了，而且最重要的是现在的<code>submit</code>事件中只关注<code>DOM</code>操作了，干脆大刀阔斧的把它移到外层去。于是咱们引入视图<code>View</code>了。  </p>
<p><figure class="highlight lang-javascript"><pre><span class="keyword">var</span> TodoList = <span class="keyword">function</span>(){};

TodoList.prototype.add = <span class="keyword">function</span>(options){
  $.ajax({
    url: <span class="string">'/add'</span>,
    type: <span class="string">'POST'</span>,
    dataType: <span class="string">'json'</span>,
    data: { todoContent: options.todoContent },
    success: options.success
  });
};

<span class="keyword">var</span> NewTodoView = <span class="keyword">function</span>(options){
  <span class="keyword">var</span> todoList = options.todoList;

  $(<span class="string">'#new-todo form'</span>).submit(<span class="keyword">function</span>(e){
    e.preventDefault();
    
    todoList.add({
      todoContent: $(<span class="string">'#new-todo'</span>).find(<span class="string">'textarea'</span>).val(),
      success: <span class="keyword">function</span>(data){
        $(<span class="string">'#todo-list ul'</span>).append(<span class="string">'&lt;li&gt;'</span> + data.todoContent + <span class="string">'&lt;/li&gt;'</span>);
        $(<span class="string">'#new-todo'</span>).find(<span class="string">'textarea'</span>).val(<span class="string">''</span>);
      }
    });
  });
};

$(<span class="keyword">function</span>(){
  <span class="keyword">var</span> todoList = <span class="keyword">new</span> TodoList();
  <span class="keyword">new</span> NewTodoView({ todoList: todoList });
});
</pre></figure><br>恩，现如今<code>$(document).ready</code>中就简洁得只剩我们之前所说的应用启动代码了。虽然代码已经组件化了，也工作得很好，但是仍然有需要重构的地方。<code>NewTodoView</code>目前看上去都不怎么像一个对象的行为，所以继续重构之。  </p>
<p><figure class="highlight lang-javascript"><pre><span class="keyword">var</span> TodoList = <span class="keyword">function</span>(){};

TodoList.prototype.add = <span class="keyword">function</span>(options){
  $.ajax({
    url: <span class="string">'/add'</span>,
    type: <span class="string">'POST'</span>,
    dataType: <span class="string">'json'</span>,
    data: { todoContent: options.todoContent },
    success: options.success
  });
};

<span class="keyword">var</span> NewTodoView = <span class="keyword">function</span>(options){
  <span class="keyword">this</span>.todoList = options.todoList;

  $(<span class="string">'#new-todo form'</span>).submit($.proxy(<span class="keyword">this</span>.addTodo, <span class="keyword">this</span>));
};

NewTodoView.prototype.addTodo = <span class="keyword">function</span>(e){
  e.preventDefault();
    
  <span class="keyword">this</span>.todoList.add({
    todoContent: $(<span class="string">'#new-todo'</span>).find(<span class="string">'textarea'</span>).val(),
    success: <span class="keyword">function</span>(data){
      $(<span class="string">'#todo-list ul'</span>).append(<span class="string">'&lt;li&gt;'</span> + data.todoContent + <span class="string">'&lt;/li&gt;'</span>);
      $(<span class="string">'#new-todo'</span>).find(<span class="string">'textarea'</span>).val(<span class="string">''</span>);
    }
  });
};

$(<span class="keyword">function</span>(){
  <span class="keyword">var</span> todoList = <span class="keyword">new</span> TodoList();
  <span class="keyword">new</span> NewTodoView({ todoList: todoList });
});
</pre></figure><br>这里用到了<code>jQuery</code>中的<code>$.proxy()</code>方法来解决<code>this</code>作用域的问题，玩<code>JavaScript</code>的童鞋们应该都很了解作用域这个东东。接下来，咱干点有关洁癖的事情，鉴于要保证代码的清晰、方便阅读，咱把<code>success</code>里面的行为采用<code>callback</code>的形式来完成。  </p>
<p><figure class="highlight lang-javascript"><pre><span class="comment">/*前面不变*/</span>
NewTodoView.prototype.addTodo = <span class="keyword">function</span>(e){
  e.preventDefault();
  <span class="keyword">var</span> that = <span class="keyword">this</span>;

  <span class="keyword">this</span>.todoList.add({
    todoContent: $(<span class="string">'#new-todo'</span>).find(<span class="string">'textarea'</span>).val(),
    success: <span class="keyword">function</span>(data){
      that.appendTodo(data.todoContent);
      that.clearTextArea();
    }
  });
};

NewTodoView.prototype.appendTodo = <span class="keyword">function</span>(todoContent){
  $(<span class="string">'#todo-list ul'</span>).append(<span class="string">'&lt;li&gt;'</span> + todoContent + <span class="string">'&lt;/li&gt;'</span>);
};

NewTodoView.prototype.clearTextArea = <span class="keyword">function</span>(){
  $(<span class="string">'#new-todo'</span>).find(<span class="string">'textarea'</span>).val(<span class="string">''</span>);
};
<span class="comment">/*后面也不变*/</span>
</pre></figure><br>至此，重构的第一个版本其实就算得上大功告成了，已经达到前面提出的三大方针政策。文章果然比较长，所以我决定还是分成了上、下两节，当前这篇中完全没涉及到<code>backbone</code>，所以到此就打住了，敬请关注下回分解。</p>
]]></content>
    <category scheme="http://heroicyang.com/tags/javascript/" term="javascript"/>
    <category scheme="http://heroicyang.com/tags/backbone/" term="backbone"/>
    <category scheme="http://heroicyang.com/tags/mvc/" term="mvc"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[Backbone之旅：前端MVC架构初体验（下）]]></title>
    <link href="http://heroicyang.com/2012/08/09/to-backbone-tutorial-2/"/>
    <id>http://heroicyang.com/2012/08/09/to-backbone-tutorial-2/</id>
    <published>2012-08-08T16:59:00.000Z</published>
    <updated>2013-05-24T15:17:22.000Z</updated>
    <content type="html"><![CDATA[<p>继<a href="http://heroicyang.com/2012/08/08/to-backbone-tutorial-1">《Backbone之旅：前端MVC架构初体验（上）》</a>，上篇中最后的代码已经完全达到最初提出的几点要求，现在就结合<code>Backbone</code>提供的能力，来继续精简代码。最后的目标就是将上篇中的代码全部重构为<code>Backbone</code>的<code>MVC</code>模式。  </p>
<p>上篇中最后一次改造就已经使用到了<code>callback</code>的方式，所以我们索性再加上<code>Event</code>机制吧，因为<code>Backbone</code>内置了这个能力。  </p>
<p><figure class="highlight lang-javascript"><pre><span class="keyword">var</span> events = _.clone(Backbone.Events);

<span class="keyword">var</span> TodoList = <span class="keyword">function</span>(){};

TodoList.prototype.add = <span class="keyword">function</span>(options){
  $.ajax({
    url: <span class="string">'/add'</span>,
    type: <span class="string">'POST'</span>,
    dataType: <span class="string">'json'</span>,
    data: { todoContent: options.todoContent },
    success: options.success
  });
};

<span class="keyword">var</span> NewTodoView = <span class="keyword">function</span>(options){
  <span class="keyword">this</span>.todoList = options.todoList;

  events.on(<span class="string">'todo:add'</span>, <span class="keyword">this</span>.appendTodo, <span class="keyword">this</span>);
  events.on(<span class="string">'todo:add'</span>, <span class="keyword">this</span>.clearTextArea, <span class="keyword">this</span>);

  $(<span class="string">'#new-todo form'</span>).submit($.proxy(<span class="keyword">this</span>.addTodo, <span class="keyword">this</span>));
};

NewTodoView.prototype.addTodo = <span class="keyword">function</span>(e){
  e.preventDefault();

  <span class="keyword">this</span>.todoList.add({
    todoContent: $(<span class="string">'#new-todo'</span>).find(<span class="string">'textarea'</span>).val(),
    success: <span class="keyword">function</span>(data){
      events.trigger(<span class="string">'todo:add'</span>, data.todoContent);
    }
  });
};

<span class="comment">/*后面不变*/</span>
</pre></figure><br>现在既然调用<code>add()</code>时传入的<code>success</code>属性已经完全不涉及到<code>DOM</code>操作了，而是单纯的事件触发，那完全可以把这个行为放置到<code>TodoList</code>原型的<code>add()</code>方法中去了，这样重用性更高。  </p>
<p><a name="more"></a></p>
<p><figure class="highlight lang-javascript"><pre><span class="comment">/* … */</span>
TodoList.prototype.add = <span class="keyword">function</span>(todoContent){
  $.ajax({
    url: <span class="string">'/add'</span>,
    type: <span class="string">'POST'</span>,
    dataType: <span class="string">'json'</span>,
    data: { todoContent: todoContent },
    success: <span class="keyword">function</span>(data){
      events.trigger(<span class="string">'todo:add'</span>, data.todoContent);
    }
  });
};
<span class="comment">/* … */</span>
NewTodoView.prototype.addTodo = <span class="keyword">function</span>(e){
  e.preventDefault();

  <span class="keyword">this</span>.todoList.add($(<span class="string">'#new-todo'</span>).find(<span class="string">'textarea'</span>).val());
};
<span class="comment">/* … */</span>
</pre></figure><br>接下来，咱看看在<code>NewTodoView</code>这个视图中事件订阅所触发的对应方法<code>appendTodo()</code>和<code>clearTextArea()</code>中，涉及到的是处在同一级别的不同的<code>DOM</code>元素节点，也就是说在<code>NewTodoView</code>这个视图中，我们处理了两个<code>DOM</code>元素，这似乎和我们之前提到的“单一职责原则”相违背了，所以还有待进一步的改进。  </p>
<p>我们分别把新增<code>Todo</code>的视图和负责展示<code>Todo Item</code>的视图分开定义，使其符合“单一职责原则”。  </p>
<p><figure class="highlight lang-javascript"><pre><span class="comment">/* 前面不变 */</span>
<span class="keyword">var</span> NewTodoView = <span class="keyword">function</span>(options){
  <span class="keyword">this</span>.todoList = options.todoList;

  events.on(<span class="string">'todo:add'</span>, <span class="keyword">this</span>.clearTextArea, <span class="keyword">this</span>);

  $(<span class="string">'#new-todo form'</span>).submit($.proxy(<span class="keyword">this</span>.addTodo, <span class="keyword">this</span>));
};

NewTodoView.prototype.addTodo = <span class="keyword">function</span>(e){
  e.preventDefault();

  <span class="keyword">this</span>.todoList.add($(<span class="string">'#new-todo'</span>).find(<span class="string">'textarea'</span>).val());
};

NewTodoView.prototype.clearTextArea = <span class="keyword">function</span>(){
  $(<span class="string">'#new-todo'</span>).find(<span class="string">'textarea'</span>).val(<span class="string">''</span>);
};

<span class="comment">/* 用于展示Todo Item */</span>
<span class="keyword">var</span> TodoView = <span class="keyword">function</span>(){
  events.on(<span class="string">'todo:add'</span>, <span class="keyword">this</span>.appendTodo, <span class="keyword">this</span>);
};

TodoView.prototype.appendTodo = <span class="keyword">function</span>(todoContent){
  $(<span class="string">'#todo-list ul'</span>).append(<span class="string">'&lt;li&gt;'</span> + todoContent + <span class="string">'&lt;/li&gt;'</span>);
};

<span class="comment">/* 应用程序启动 */</span>
$(<span class="keyword">function</span>(){
  <span class="keyword">var</span> todoList = <span class="keyword">new</span> TodoList();
  <span class="keyword">new</span> NewTodoView({ todoList: todoList });
  <span class="keyword">new</span> TodoView();
});
</pre></figure><br>现在每个<code>View</code>里面只依赖一个顶层的<code>HTML Element</code>了，而在各自的<code>View</code>里面多次使用到了<code>$(&#39;#new-todo&#39;)</code>这样的代码，所以干脆将其在初始化的时候作为<code>View</code>的一个属性来提供吧。  </p>
<p><figure class="highlight lang-javascript"><pre><span class="comment">/* 前面依旧不变 */</span>
<span class="keyword">var</span> NewTodoView = <span class="keyword">function</span>(options){
  <span class="keyword">this</span>.todoList = options.todoList;
  <span class="keyword">this</span>.el = $(<span class="string">'#new-todo'</span>);  <span class="comment">//定义一个el属性ß</span>

  events.on(<span class="string">'todo:add'</span>, <span class="keyword">this</span>.clearTextArea, <span class="keyword">this</span>);

  <span class="keyword">this</span>.el.find(<span class="string">'form'</span>).submit($.proxy(<span class="keyword">this</span>.addTodo, <span class="keyword">this</span>));
};

NewTodoView.prototype.addTodo = <span class="keyword">function</span>(e){
  e.preventDefault();

  <span class="keyword">this</span>.todoList.add(<span class="keyword">this</span>.el.find(<span class="string">'textarea'</span>).val());
};

NewTodoView.prototype.clearTextArea = <span class="keyword">function</span>(){
  <span class="keyword">this</span>.el.find(<span class="string">'textarea'</span>).val(<span class="string">''</span>);
};

<span class="keyword">var</span> TodoView = <span class="keyword">function</span>(){
  <span class="keyword">this</span>.el = $(<span class="string">'#todo-list'</span>);
  events.on(<span class="string">'todo:add'</span>, <span class="keyword">this</span>.appendTodo, <span class="keyword">this</span>);
};

TodoView.prototype.appendTodo = <span class="keyword">function</span>(todoContent){
  <span class="keyword">this</span>.el.find(<span class="string">'ul'</span>).append(<span class="string">'&lt;li&gt;'</span> + todoContent + <span class="string">'&lt;/li&gt;'</span>);
};
<span class="comment">/* 后面不变 */</span>
</pre></figure><br>此时观察发现，两个<code>View</code>当中还保留着对<code>DOM</code>节点的依赖，其重用度依然不高，于是可采用实例化<code>View</code>的时候传入<code>el</code>参数来解决这个问题。  </p>
<p><figure class="highlight lang-javascript"><pre><span class="comment">/* 前面不变 */</span>
<span class="keyword">var</span> NewTodoView = <span class="keyword">function</span>(options){
  <span class="keyword">this</span>.todoList = options.todoList;
  <span class="keyword">this</span>.el = options.el;

  events.on(<span class="string">'todo:add'</span>, <span class="keyword">this</span>.clearTextArea, <span class="keyword">this</span>);

  <span class="keyword">this</span>.el.find(<span class="string">'form'</span>).submit($.proxy(<span class="keyword">this</span>.addTodo, <span class="keyword">this</span>));
};
<span class="comment">/* NewTodoView的原型方法也不变 */</span>

<span class="keyword">var</span> TodoView = <span class="keyword">function</span>(options){
  <span class="keyword">this</span>.el = options.el;
  events.on(<span class="string">'todo:add'</span>, <span class="keyword">this</span>.appendTodo, <span class="keyword">this</span>);
};
<span class="comment">/* TodoView的原型方法也不变 */</span>

<span class="comment">/* 初始化View的时候传入el */</span>	
$(<span class="keyword">function</span>(){
  <span class="keyword">var</span> todoList = <span class="keyword">new</span> TodoList();
  <span class="keyword">new</span> NewTodoView({ el: $(<span class="string">'#new-todo'</span>), todoList: todoList });
  <span class="keyword">new</span> TodoView({ el: $(<span class="string">'#todo-list'</span>) });
});
</pre></figure><br><code>View</code>中我们频繁使用到了<code>jQuery</code>的<code>find()</code>方法来查找<code>View</code>所在<code>el</code>下面的子元素，所以可以考虑将这作为<code>View</code>的特性来提供，于是我们为<code>View</code>定义这样一个名叫<code>$</code>方法，然后替换掉<code>this.el.find()</code>这样的写法。  </p>
<p><figure class="highlight lang-javascript"><pre><span class="comment">/* … */</span>
<span class="keyword">var</span> NewTodoView = <span class="keyword">function</span>(options){
  <span class="keyword">this</span>.todoList = options.todoList;
  <span class="keyword">this</span>.el = options.el;

  events.on(<span class="string">'todo:add'</span>, <span class="keyword">this</span>.clearTextArea, <span class="keyword">this</span>);

  <span class="keyword">this</span>.$(<span class="string">'form'</span>).submit($.proxy(<span class="keyword">this</span>.addTodo, <span class="keyword">this</span>));
};

NewTodoView.prototype.addTodo = <span class="keyword">function</span>(e){
  e.preventDefault();

  <span class="keyword">this</span>.todoList.add(<span class="keyword">this</span>.$(<span class="string">'textarea'</span>).val());
};

NewTodoView.prototype.clearTextArea = <span class="keyword">function</span>(){
  <span class="keyword">this</span>.$(<span class="string">'textarea'</span>).val(<span class="string">''</span>);
};

NewTodoView.prototype.$ = <span class="keyword">function</span>(selector){
  <span class="keyword">return</span> <span class="keyword">this</span>.el.find(selector);
};

<span class="keyword">var</span> TodoView = <span class="keyword">function</span>(options){
  <span class="keyword">this</span>.el = options.el;
  events.on(<span class="string">'todo:add'</span>, <span class="keyword">this</span>.appendTodo, <span class="keyword">this</span>);
};

TodoView.prototype.appendTodo = <span class="keyword">function</span>(todoContent){
  <span class="keyword">this</span>.$(<span class="string">'ul'</span>).append(<span class="string">'&lt;li&gt;'</span> + todoContent + <span class="string">'&lt;/li&gt;'</span>);
};

TodoView.prototype.$ = <span class="keyword">function</span>(selector){
  <span class="keyword">return</span> <span class="keyword">this</span>.el.find(selector);
};
<span class="comment">/* … */</span>
</pre></figure><br>上面的代码越来越多了，看上去好像咱是干的坏事，而不是往好的方向发展啊。是的，如果每个<code>View</code>都有很多自己的特性（方法），那向上面这样着实太痛苦了。看样子是时候请出<code>Backbone</code>提供的<code>View</code>特性了。OK，把我们自己的<code>View</code>转移到<code>Backbone</code>的。  </p>
<p><figure class="highlight lang-javascript"><pre><span class="comment">/* … */</span>
<span class="keyword">var</span> NewTodoView = Backbone.View.extend({
  initialize: <span class="keyword">function</span>(options){
    <span class="keyword">this</span>.todoList = options.todoList;
    <span class="keyword">this</span>.el = options.el;

    events.on(<span class="string">'todo:add'</span>, <span class="keyword">this</span>.clearTextArea, <span class="keyword">this</span>);

    <span class="keyword">this</span>.$(<span class="string">'form'</span>).submit($.proxy(<span class="keyword">this</span>.addTodo, <span class="keyword">this</span>));
  },
  addTodo: <span class="keyword">function</span>(e){
    e.preventDefault();

    <span class="keyword">this</span>.todoList.add(<span class="keyword">this</span>.$(<span class="string">'textarea'</span>).val());
  },
  clearTextArea: <span class="keyword">function</span>(){
    <span class="keyword">this</span>.$(<span class="string">'textarea'</span>).val(<span class="string">''</span>);
  },
  $: <span class="keyword">function</span>(selector){
    <span class="keyword">return</span> <span class="keyword">this</span>.el.find(selector);
  }
});

<span class="keyword">var</span> TodoView = Backbone.View.extend({
  initialize: <span class="keyword">function</span>(options){
    <span class="keyword">this</span>.el = options.el;
    events.on(<span class="string">'todo:add'</span>, <span class="keyword">this</span>.appendTodo, <span class="keyword">this</span>);
  },
  appendTodo: <span class="keyword">function</span>(todoContent){
    <span class="keyword">this</span>.$(<span class="string">'ul'</span>).append(<span class="string">'&lt;li&gt;'</span> + todoContent + <span class="string">'&lt;/li&gt;'</span>);
  },
  $: <span class="keyword">function</span>(selector){
    <span class="keyword">return</span> <span class="keyword">this</span>.el.find(selector);
  }
});
<span class="comment">/* … */</span>
</pre></figure><br>由于<code>Backbone</code>的<code>View</code>已经提供了我们实现的<code>$()</code>方法的能力，也叫<code>$</code>（这也是之前我们自己命名的原因）；同时<code>Backbone</code>的<code>View</code>也提供了<code>this.el</code>的能力，所以可以把它们从代码中显示的移除了。  </p>
<p><figure class="highlight lang-javascript"><pre><span class="comment">/* … */</span>
<span class="keyword">var</span> NewTodoView = Backbone.View.extend({
  initialize: <span class="keyword">function</span>(options){
    <span class="keyword">this</span>.todoList = options.todoList;

    events.on(<span class="string">'todo:add'</span>, <span class="keyword">this</span>.clearTextArea, <span class="keyword">this</span>);

    <span class="keyword">this</span>.$(<span class="string">'form'</span>).submit($.proxy(<span class="keyword">this</span>.addTodo, <span class="keyword">this</span>));
  },
  addTodo: <span class="keyword">function</span>(e){
    e.preventDefault();

    <span class="keyword">this</span>.todoList.add(<span class="keyword">this</span>.$(<span class="string">'textarea'</span>).val());
  },
  clearTextArea: <span class="keyword">function</span>(){
    <span class="keyword">this</span>.$(<span class="string">'textarea'</span>).val(<span class="string">''</span>);
  }
});

<span class="keyword">var</span> TodoView = Backbone.View.extend({
  initialize: <span class="keyword">function</span>(options){
    events.on(<span class="string">'todo:add'</span>, <span class="keyword">this</span>.appendTodo, <span class="keyword">this</span>);
  },
  appendTodo: <span class="keyword">function</span>(todoContent){
    <span class="keyword">this</span>.$(<span class="string">'ul'</span>).append(<span class="string">'&lt;li&gt;'</span> + todoContent + <span class="string">'&lt;/li&gt;'</span>);
  }
});
<span class="comment">/* 启动代码依然不变 */</span>
</pre></figure><br>现在可以回过头来看看<code>ajax</code>那部分了，由于<code>Backbone</code>提供了<code>Model</code>的能力，这个就是用于和服务端打交道的，所以将长长的<code>ajax</code>代码改写为这一方式。  </p>
<p><figure class="highlight lang-javascript"><pre><span class="comment">/* … */</span>
<span class="keyword">var</span> Todo = Backbone.Model.extend({
  url: <span class="string">'/add'</span>
});

<span class="keyword">var</span> TodoList = <span class="keyword">function</span>(){};

TodoList.prototype.add = <span class="keyword">function</span>(todoContent){
  <span class="keyword">var</span> todo = <span class="keyword">new</span> Todo();
  todo.save({ todoContent: todoContent },{
    success: <span class="keyword">function</span>(model, data){
      events.trigger(<span class="string">'todo:add'</span>, data.todoContent);
    }
  });
};
<span class="comment">/* … */</span>
</pre></figure><br>同时，<code>Backbone</code>中还提供了一个<code>Collection</code>的概念，也就是<code>Model</code>的集合，比如我们这个案例中，每次创建单条的<code>Todo</code>，然后形成<code>Todo List</code>。当然，我们的任何数据都应该是以多条记录的方式存在的。所以，我们同时将上面的<code>TodoList</code>的实现改为<code>Collection</code>。  </p>
<p>而且，<code>Backbone</code>的<code>Collection</code>已经支持了<code>Event</code>机制，所以我们也无需自定义<code>events</code>了，于是开头的<code>events</code>变量也一并移除了。  </p>
<p><figure class="highlight lang-javascript"><pre><span class="keyword">var</span> Todo = Backbone.Model.extend({
  url: <span class="string">'/add'</span>
});

<span class="keyword">var</span> TodoList = Backbone.Collection.extend({
  add: <span class="keyword">function</span>(todoContent){
    <span class="keyword">var</span> todo = <span class="keyword">new</span> Todo(),
        that = <span class="keyword">this</span>;
    todo.save({ todoContent: todoContent },{
      success: <span class="keyword">function</span>(model, data){
        that.trigger(<span class="string">'add'</span>, data.todoContent);
      }
    });
  }
});

<span class="keyword">var</span> NewTodoView = Backbone.View.extend({
  initialize: <span class="keyword">function</span>(options){
    <span class="keyword">this</span>.todoList = options.todoList;

    <span class="keyword">this</span>.todoList.on(<span class="string">'add'</span>, <span class="keyword">this</span>.clearTextArea, <span class="keyword">this</span>);

    <span class="keyword">this</span>.$(<span class="string">'form'</span>).submit($.proxy(<span class="keyword">this</span>.addTodo, <span class="keyword">this</span>));
  },
  addTodo: <span class="keyword">function</span>(e){
    e.preventDefault();

    <span class="keyword">this</span>.todoList.add(<span class="keyword">this</span>.$(<span class="string">'textarea'</span>).val());
  },
  clearTextArea: <span class="keyword">function</span>(){
    <span class="keyword">this</span>.$(<span class="string">'textarea'</span>).val(<span class="string">''</span>);
  }
});

<span class="keyword">var</span> TodoView = Backbone.View.extend({
  initialize: <span class="keyword">function</span>(options){
    <span class="keyword">this</span>.todoList = options.todoList;
    <span class="keyword">this</span>.todoList.on(<span class="string">'add'</span>, <span class="keyword">this</span>.appendTodo, <span class="keyword">this</span>);
  },
  appendTodo: <span class="keyword">function</span>(todoContent){
    <span class="keyword">this</span>.$(<span class="string">'ul'</span>).append(<span class="string">'&lt;li&gt;'</span> + todoContent + <span class="string">'&lt;/li&gt;'</span>);
  }
});

$(<span class="keyword">function</span>(){
  <span class="keyword">var</span> todoList = <span class="keyword">new</span> TodoList();
  <span class="keyword">new</span> NewTodoView({ el: $(<span class="string">'#new-todo'</span>), todoList: todoList });
  <span class="keyword">new</span> TodoView({ el: $(<span class="string">'#todo-list'</span>), todoList: todoList });
});
</pre></figure><br><code>Collection</code>提供了一个名叫<code>create()</code>的方法，其可以根据<code>Collection</code>的<code>Model</code>属性创建一个<code>Model</code>的实例，并执行<code>Model</code>的<code>save()</code>方法。所以我们的<code>TodoList</code>中的<code>add()</code>方法已经可以废去了。我们只需为<code>TodoList</code>提供<code>Model</code>属性的值即可，然后在<code>NewTodoView</code>的<code>addTodo()</code>方法中，替换<code>this.todoList.add()</code>方法为<code>this.todoList.create()</code>。  </p>
<p><figure class="highlight lang-javascript"><pre>	
<span class="comment">/* … */</span>
<span class="keyword">var</span> TodoList = Backbone.Collection.extend({
  model: Todo
});

<span class="keyword">var</span> NewTodoView = Backbone.View.extend({
  initialize: <span class="keyword">function</span>(options){
    <span class="keyword">this</span>.todoList = options.todoList;

    <span class="keyword">this</span>.todoList.on(<span class="string">'add'</span>, <span class="keyword">this</span>.clearTextArea, <span class="keyword">this</span>);

    <span class="keyword">this</span>.$(<span class="string">'form'</span>).submit($.proxy(<span class="keyword">this</span>.addTodo, <span class="keyword">this</span>));
  },
  addTodo: <span class="keyword">function</span>(e){
    e.preventDefault();

    <span class="keyword">this</span>.todoList.create({ todoContent: <span class="keyword">this</span>.$(<span class="string">'textarea'</span>).val() });  <span class="comment">//替换为create方法</span>
  },
  clearTextArea: <span class="keyword">function</span>(){
    <span class="keyword">this</span>.$(<span class="string">'textarea'</span>).val(<span class="string">''</span>);
  }
});
<span class="comment">/* … */</span>
</pre></figure><br>这时，我们的<code>Model</code>、<code>Collection</code>、<code>View</code>都已经齐上阵了。由于<code>Backbone</code>的<code>View</code>已经内置<code>collection</code>属性，使得我们可以设置、获取<code>View</code>对应的<code>Collection</code>，所以我们完全无需手动在<code>View</code>的内部来定义一个<code>todoList</code>的变量了。  </p>
<p><figure class="highlight lang-javascript"><pre><span class="comment">/* … */</span>
<span class="keyword">var</span> NewTodoView = Backbone.View.extend({
  initialize: <span class="keyword">function</span>(options){
    <span class="keyword">this</span>.collection.on(<span class="string">'add'</span>, <span class="keyword">this</span>.clearTextArea, <span class="keyword">this</span>);

    <span class="keyword">this</span>.$(<span class="string">'form'</span>).submit($.proxy(<span class="keyword">this</span>.addTodo, <span class="keyword">this</span>));
  },
  addTodo: <span class="keyword">function</span>(e){
    e.preventDefault();

    <span class="keyword">this</span>.collection.create({ todoContent: <span class="keyword">this</span>.$(<span class="string">'textarea'</span>).val() });
  },
  clearTextArea: <span class="keyword">function</span>(){
    <span class="keyword">this</span>.$(<span class="string">'textarea'</span>).val(<span class="string">''</span>);
  }
});

<span class="keyword">var</span> TodoView = Backbone.View.extend({
  initialize: <span class="keyword">function</span>(options){
    <span class="keyword">this</span>.collection.on(<span class="string">'add'</span>, <span class="keyword">this</span>.appendTodo, <span class="keyword">this</span>);
  },
  appendTodo: <span class="keyword">function</span>(todo){
    <span class="keyword">this</span>.$(<span class="string">'ul'</span>).append(<span class="string">'&lt;li&gt;'</span> + todo.get(<span class="string">'todoContent'</span>) + <span class="string">'&lt;/li&gt;'</span>);
  }
});

$(<span class="keyword">function</span>(){
  <span class="keyword">var</span> todoList = <span class="keyword">new</span> TodoList();
  <span class="keyword">new</span> NewTodoView({ el: $(<span class="string">'#new-todo'</span>), collection: todoList });
  <span class="keyword">new</span> TodoView({ el: $(<span class="string">'#todo-list'</span>), collection: todoList });
});
</pre></figure><br>至此，完整的基于<code>Backbone</code>的<code>Model</code>、<code>Collection</code>、<code>View</code>模式就构建好了。如果说还有什么瑕疵的话，应该就是一些表层功夫了，那就是咱们的<code>HTML Element</code>的<code>append</code>了，需要做一些过滤，比如用户输入<code>JavaScript</code>代码那就糟糕了。  </p>
<p><figure class="highlight lang-javascript"><pre><span class="keyword">this</span>.$(<span class="string">'ul'</span>).append(<span class="string">'&lt;li&gt;'</span> + todo.get(<span class="string">'todoContent'</span>) + <span class="string">'&lt;/li&gt;'</span>);
调整为
<span class="keyword">this</span>.$(<span class="string">'ul'</span>).append(<span class="string">'&lt;li&gt;'</span> + todo.escape(<span class="string">'todoContent'</span>) + <span class="string">'&lt;/li&gt;'</span>);
</pre></figure><br>这样就Perfect了。文章忒长了点，但是为了从一个<code>0</code>变成一个<code>1</code>，我想应该还是很有意思的。</p>
]]></content>
    <category scheme="http://heroicyang.com/tags/javascript/" term="javascript"/>
    <category scheme="http://heroicyang.com/tags/backbone/" term="backbone"/>
    <category scheme="http://heroicyang.com/tags/mvc/" term="mvc"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[像黑客一样写博客]]></title>
    <link href="http://heroicyang.com/2012/08/26/blogging-like-a-hacker/"/>
    <id>http://heroicyang.com/2012/08/26/blogging-like-a-hacker/</id>
    <published>2012-08-26T15:24:00.000Z</published>
    <updated>2013-01-29T14:40:15.000Z</updated>
    <content type="html"><![CDATA[<p>“像黑客一样写博客”，这个标题是网络上对<code>Octopress</code>（其实应该是<code>Jekyll</code>）的评价，而这一评价是来自一篇几年前的<a href="http://tom.preston-werner.com/2008/11/17/blogging-like-a-hacker.html">文章</a>。当我将自己的博客抹掉并重新开始的时候，我也准备以这个标题来作为这次的新起点。  </p>
<p>其实早就有换掉<code>WordPress</code>的想法，一是因为它太臃肿了，我只是想简单的写写博客，用不着那么多强大的功能；二是它对插入代码的支持让我绝望了，每次用<code>Markdown</code>写好文章，复制其<code>HTML</code>到<code>WordPress</code>之后，都要调整好半天的样式；三是我之前的博客中太多的碎碎念之类的水文了，可谓杂、乱，并不像一个记录技术的博客。综合这些借口，我每次登录到<code>WordPress</code>后台都没有再写文章的激情。<br><a name="more"></a>
而之前我也和<a href="http://veryb.us/">fiture</a>聊到用<a href="http://heroicyang.com/tags/nodejs/">Nodejs</a>来重新写个博客，也当学习练手。经过间歇性的聊聊之后，我提议说不弄数据库了，直接将文章以<code>Markdown</code>的格式<code>push</code>到<code>Github</code>吧等等的初步想法。当时我们觉得还不错，因为也没了解过有没有这样的东西存在，之后我下意识地搜了下。结果发现了<code>OctoPress</code>这个东西，了解之后感觉完全正合我意啊，所以二话不说就直接给换上了。  </p>
<p>于是我总算是终于弃掉了<code>WordPress</code>，用上<code>Octopress</code>这个高级货，可谓得心应手。  </p>
<p>其实我也就冲着我认为的这几点优势：</p>
<ol>
<li>直接使用<code>Markdown</code>写文章</li>
<li>全站静态化，根据<code>Markdown</code>生成文章的静态页面</li>
<li>所以直接在<code>Terminal</code>把文章<code>push</code>到我的<a href="https://github.com/heroicYang/heroicyang.com">Github</a>上即可，有版本管理真好</li>
<li>然后加之<code>Github Page</code>的支持，虽然有一些些小问题，比如<code>缓存</code>，但瑕不掩瑜</li>
<li>整个写作过程和写代码的过程是一致的，符合码农的行为习惯，也就是所谓的“像黑客一样写博客”</li>
</ol>
<p>这样，就只需要一个<code>Markdown</code>编辑器（推荐<a href="http://mouapp.com/">Mou</a>和<a href="http://www.sublimetext.com/2">Sublime Text 2</a>），再配合终端的<code>git</code>命令就OK了，其余的都不用管了，交给第三方去。比如：评论系统我就采用了国内的<a href="http://duoshuo.com/">多说</a>；然后用<a href="http://dropbox.com/">Dropbox</a>来保存文章中会用到的图片，因为<code>Dropbox</code>被<code>GFW</code>认证，所以再利用<a href="http://en.wikipedia.org/wiki/Nginx">Nginx</a>做个<a href="http://en.wikipedia.org/wiki/Reverse_proxy">反向代理</a>。一切都妥妥的了。  </p>
<p>以前博客的那些废柴文章都不要了，不过还是做了个备份，算是纪念好了。而把近期写的3篇与<a href="http://heroicyang.com/tags/javascript/">JavaScript</a>相关的文章转移了过来，重新开始技术博客的历程，见证成长。</p>
]]></content>
    <category scheme="http://heroicyang.com/tags/blog/" term="blog"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[JavaScript Event Loop 浅析]]></title>
    <link href="http://heroicyang.com/2012/08/28/javascript-event-loop/"/>
    <id>http://heroicyang.com/2012/08/28/javascript-event-loop/</id>
    <published>2012-08-28T14:52:00.000Z</published>
    <updated>2013-05-24T15:17:33.000Z</updated>
    <content type="html"><![CDATA[<p>最近在学习<code>Nodejs</code>的过程中深入的了解了<code>异步编程</code>这个概念，为了更好的使用<code>Nodejs</code>，这些概念不可不知。在以前作为一个<code>JavaScript</code>用户的时候，完全是不知道它是怎么运行的，对好些概念也是“知其然不知其所以然”。  </p>
<p>对于客户端的<code>JavaScript</code>和<code>Nodejs</code>来说其实差距不是很大，这回就从客户端方面来说说<code>Event Loop</code>这个概念吧，算是<code>异步编程</code>的一个切入点吧。其实<code>jQuery</code>的作者John Resig在几年前就写了一篇好文章<a href="http://ejohn.org/blog/how-javascript-timers-work/">How JavaScript Timers Work</a>，来讲述<code>timer</code>和<code>事件</code>在浏览器中是怎样工作的，我也是通过这篇文章才“知其所以然”。  </p>
<h3>问题场景</h3>
<p>先来看看一段代码：  </p>
<figure class="highlight lang-html"><pre><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#"</span> <span class="attribute">id</span>=<span class="value">"doBtn"</span>&gt;</span>do something<span class="tag">&lt;/<span class="title">a</span>&gt;</span>
<span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"status"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">
  <span class="keyword">void</span> <span class="keyword">function</span>() {
    <span class="keyword">var</span> doBtn = document.getElementById(<span class="string">'doBtn'</span>)
      , status = document.getElementById(<span class="string">'status'</span>);

    doBtn.onclick = <span class="keyword">function</span>(e) {
      e.preventDefault();

      status.innerText = <span class="string">'doing...please wait...'</span>;  <span class="comment">//开始啦</span>
      sleep(<span class="number">10000</span>);  <span class="comment">//模拟一个耗时较长的计算过程，10s</span>
      status.innerText = <span class="string">'done'</span>;  <span class="comment">//完成啦</span>
    };
  }();

  <span class="function"><span class="keyword">function</span> <span class="title">sleep</span><span class="params">(ms)</span> {</span>
    <span class="keyword">var</span> start = <span class="keyword">new</span> Date();
    <span class="keyword">while</span> (<span class="keyword">new</span> Date() - start &lt;= ms) {}
  }
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</pre></figure>

<p>上面代码主要想完成一个功能：按钮被点击时------&gt;显示一个状态告知用户正在干一些事情------&gt;开始干------&gt;事情干完后状态变更为已完成。<br><a name="more"></a></p>
<p>看上去没问题，应该是可以工作的，于是在浏览器运行这个页面。可是现实总是残忍的，没有符合预期效果。当点击按钮之后，浏览器就冻结了，用于显示状态的<code>div</code>并没有显示，界面上也没有“doing...”这个提示；经过<code>10s</code>之后，浏览器回过神了，代表耗时较长的计算已经结束，此时用于显示状态的<code>div</code>显示“done”。  </p>
<p>究其原因：JavaScript引擎是单线程的。而此时还有必要再了解下浏览器内核都有哪些主要的常驻线程，才能解上面的疑惑。浏览器内核常驻线程大致包含以下：  </p>
<ol>
<li>浏览器GUI渲染线程</li>
<li>JavaScript引擎线程</li>
<li>浏览器定时触发器线程</li>
<li>浏览器事件触发线程</li>
<li>浏览器http异步请求线程</li>
</ol>
<p>而GUI渲染线程和JavaScript引擎线程是互斥的，JavaScript执行时GUI渲染线程是挂起的，页面将停止一切的解析和渲染行为。上面的3、4、5类线程也会产生不同的异步事件。看下面这张图就应该比较直观了。</p>
<p><img src="http://img.heroicyang.com/js-event-loop.png" alt="JavaScript-Event-Loop"></p>
<p>因为JavaScript引擎是单线程的，所以代码都是先压到队列，然后由引擎采用先进先出的方式运行。事件处理函数、timer执行函数也会排到这个队列中，然后利用一个无穷回圈，不断从队头取出函数执行，这个就是<code>Event Loop</code>。  </p>
<p>接下来还是继续用图来说明上面的代码为什么没有达到预期效果。</p>
<p><img src="http://img.heroicyang.com/js-event-loop-1.png" alt=""></p>
<p>于是结果就只看到了&quot;done&quot;。  </p>
<h3>怎样解决？</h3>
<p>使用<code>setTimeout()</code>，下面是修改后的<code>onclick</code>事件处理函数：</p>
<figure class="highlight lang-javascript"><pre>doBtn.onclick = <span class="keyword">function</span>(e) {
  e.preventDefault();

  status.innerText = <span class="string">'doing...please wait...'</span>;  <span class="comment">//开始啦</span>
  
  setTimeout(<span class="keyword">function</span>() {
    sleep(<span class="number">10000</span>);  <span class="comment">//模拟一个耗时较长的计算过程，10s</span>
    status.innerText = <span class="string">'done'</span>;  <span class="comment">//完成啦</span>
  }, <span class="number">0</span>);  <span class="comment">// 0ms delay</span>
};
</pre></figure>

<p>为什么这样就解决了呢？还是用上面的队列的图来解释。</p>
<p><img src="http://img.heroicyang.com/js-event-loop-2.png" alt=""></p>
]]></content>
    <category scheme="http://heroicyang.com/tags/javascript/" term="javascript"/>
    <category scheme="http://heroicyang.com/tags/javascript-timer/" term="javascript timer"/>
    <category scheme="http://heroicyang.com/tags/event-loop/" term="event-loop"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[理解JavaScript定时器：setTimeout和setInterval]]></title>
    <link href="http://heroicyang.com/2012/09/06/javascript-timers/"/>
    <id>http://heroicyang.com/2012/09/06/javascript-timers/</id>
    <published>2012-09-06T14:56:00.000Z</published>
    <updated>2013-05-24T15:17:38.000Z</updated>
    <content type="html"><![CDATA[<p><strong>定时器其实并不是<code>JavaScript</code>提供的，而是由浏览器（对于前端来说）提供的。</strong>所以<code>setTimeout()</code>和<code>setInterval()</code>这两个方法均是通过浏览器的顶层对象<code>window</code>进行调用，可能平时大家在使用的过程中也会省去<code>window</code>而直接使用这两个方法。  </p>
<p>这两个方法所接收的参数都一样：  </p>
<p><figure class="highlight lang-javascript"><pre>setTimeout(func|code, delay);
setInterval(func|code, delay);
</pre></figure><br>这两个方法总是被简单的认为：在多少毫秒之后就执行里面的函数或者每间隔多少毫秒就执行里面的函数，基于这种理解的话会遇到很多匪夷所思的坑。而结合<a href="http://heroicyang.com/2012/08/28/javascript-event-loop.html">上篇文章</a>中所提到的执行队列来解释的话，很多疑问都可以迎刃而解。</p>
<p>前者：在指定的毫秒数后，将定时任务处理函数（<code>func|code</code>）添加到执行队列的队尾。  </p>
<p>后者：按照指定的周期（以毫秒计），将定时任务处理函数（<code>func|code</code>）添加到执行队列的队尾。<br><a name="more"></a>
下面分别使用了<code>setInterval</code>和<code>setTimeout</code>来实现同一个功能，可运行查看效果。 </p>
<iframe src="http://sample.heroicyang.com/timer.html" style="border: 1px solid #DDD; border-radius: 3px; background: #F8F8F8; height:80px;"></iframe>

<p>这是相应的源代码：<a href="http://code.heroicyang.com/timer.html" target="_blank">传送门</a>  </p>
<p><strong>接下来继续填<code>setInterval</code>的坑。</strong>  </p>
<p>假设定时器的上一个回调执行完到下一个回调开始的这段时间为时间间隔，那么对于<code>setTimeout</code>来说，这个时间间隔理论上是应该<code>&gt;=delay</code>；而对于<code>setInterval</code>来说，这个时间间隔理论上是应该<code>&lt;=delay</code>的。</p>
<p>但事实总会有出人意料的地方，<code>setInterval</code>就是那个制造意外的东西。   </p>
<p>以下是常规的代码：   </p>
<p><figure class="highlight lang-javascript"><pre><span class="keyword">var</span> endTime = <span class="literal">null</span>;
setInterval(count, <span class="number">200</span>);
<span class="function"><span class="keyword">function</span> <span class="title">count</span><span class="params">()</span> {</span>
  <span class="keyword">var</span> elapsedTime = endTime ? (<span class="keyword">new</span> Date() - endTime) : <span class="number">200</span>;
  i++;
  console.log(<span class="string">'current count: '</span> + i + <span class="string">'.'</span> + <span class="string">'elapsed time: '</span> + elapsedTime + <span class="string">'ms'</span>);
  endTime = <span class="keyword">new</span> Date();
}
</pre></figure><br>其执行结果也比较符合理论时间，见下图。</p>
<p><img src="http://img.heroicyang.com/setInterval1.png" alt="">   </p>
<p>接下来修改代码，让<code>count()</code>方法的执行时间变长一点：  </p>
<p><figure class="highlight lang-javascript"><pre><span class="function"><span class="keyword">function</span> <span class="title">count</span><span class="params">()</span> {</span>
  <span class="keyword">var</span> elapsedTime = endTime ? (<span class="keyword">new</span> Date() - endTime) : <span class="number">200</span>;
  i++;
  console.log(<span class="string">'current count: '</span> + i + <span class="string">'.'</span> + <span class="string">'elapsed time: '</span> + elapsedTime + <span class="string">'ms'</span>);
  sleep(<span class="number">100</span>); <span class="comment">//sleep 100ms</span>
  endTime = <span class="keyword">new</span> Date();
}
</pre></figure>
执行结果如下：</p>
<p><img src="http://img.heroicyang.com/setInterval2.png" alt=""></p>
<p>结合执行队列，可以用下图对上面两种情况进行直观的解释：</p>
<p><img src="http://img.heroicyang.com/setInterval1-explain.png" alt="">   </p>
<p>接下来再次修改代码，让<code>count()</code>方法的执行时间更长，设定为<code>setInterval</code>中<code>delay</code>的<code>2</code>倍，即<code>400ms</code>：  </p>
<p><figure class="highlight lang-javascript"><pre><span class="function"><span class="keyword">function</span> <span class="title">count</span><span class="params">()</span> {</span>
  <span class="keyword">var</span> elapsedTime = endTime ? (<span class="keyword">new</span> Date() - endTime) : <span class="number">200</span>;
  i++;
  console.log(<span class="string">'current count: '</span> + i + <span class="string">'.'</span> + <span class="string">'elapsed time: '</span> + elapsedTime + <span class="string">'ms'</span>);
  sleep(<span class="number">400</span>); <span class="comment">//sleep 400ms</span>
  endTime = <span class="keyword">new</span> Date();
}
</pre></figure><br>其执行效果变为如下：</p>
<p><img src="http://img.heroicyang.com/setInterval3.png" alt="">  </p>
<p>意外发生了，每个回调之间的时间间隔竟然没有了，或者说缩短到非常小的间隔。事情大概是这样的：如果<code>setInterval</code>的定时时间到了，而前一个回调还没有执行完时，就会把这次的回调放在执行队列的队尾；如果<code>setInterval</code>的定时时间已经多次触发，而此时最前一个回调仍然还在执行，那么就会丢弃掉本次的回调。还是用图来直观说明吧。  </p>
<p>这是回调处理时间比定时时间稍微长一点点的情况：</p>
<p><img src="http://img.heroicyang.com/setInterval2-explain.png" alt="">  </p>
<p>这是回调处理时间比定时时间长很多的情况：</p>
<p><img src="http://img.heroicyang.com/setInterval3-explain.png" alt="">  </p>
<p><strong>所以，如果使用<code>setInterval</code>的话，其时间间隔总是让人捉摸不定。而使用<code>setTimeout</code>嵌套，则完全可以解决这个问题，还我们一个固定的时间间隔。</strong></p>
]]></content>
    <category scheme="http://heroicyang.com/tags/javascript/" term="javascript"/>
    <category scheme="http://heroicyang.com/tags/javascript-timer/" term="javascript timer"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[深入理解JavaScript定时器]]></title>
    <link href="http://heroicyang.com/2012/09/22/javascript-timer-in-depth/"/>
    <id>http://heroicyang.com/2012/09/22/javascript-timer-in-depth/</id>
    <published>2012-09-22T10:57:00.000Z</published>
    <updated>2013-05-24T15:17:42.000Z</updated>
    <content type="html"><![CDATA[<p>对于浏览器内部，大部分操作都是异步的生成事件并添加到<code>JavaScript引擎线程</code>的队列中，然后由<code>JavaScript引擎线程</code>进行调度执行。因此浏览器的很多事件都是和<code>JavaScript</code>相结合的，但是也有一些内部的限制。  </p>
<p>首先我们非常确定<code>JavaScript</code>是单线程的，对于浏览器来说，一个窗体中只有一个<code>JavaScript引擎线程</code>。而其他的行为，如：渲染、下载等是由单独的线程进行管理的，且具有不同的优先级。  </p>
<h2>异步事件</h2>
<p>前面提到大多数事件都是异步的，触发的时候就将回调函数添加到事件队列。浏览器提供了一个内部的回路，也就是之前所谈到的<code>Event Loop</code>，由它来负责检查队列和处理事件、执行函数等。详细可参考我的<a href="http://heroicyang.com/2012/08/28/javascript-event-loop.html">前一篇博文</a>。而<code>setTimeout</code>和<code>setInterval</code>也是将其需要执行的函数添加到事件队列。  </p>
<p><strong>事实上，大多数交互和活动都得通过事件循环。</strong><br><a name="more"></a>  </p>
<h2>事件重叠</h2>
<p>一些情况下，会有多个事件在同一时间附加到事件队列里。  </p>
<p>比如，<code>click</code>事件就会产生两个额外的事件：<code>mousedown</code>和<code>mouseup</code>。其中，<code>mouseup</code>和<code>click</code>事件会同时被添加到事件队列；而<code>mousedown</code>事件则很有可能会和另外一个事件重叠：<code>focus</code>。  </p>
<h2>setTimeout(func, 0)奇巧淫技</h2>
<p>再一次解释关于<code>0ms</code>的误解：如果当前时钟周期内执行队列空闲，则立即执行该定时器，将回调函数加入到事件队列；然后等待下一个时钟周期，再执行该回调函数。不妨来看看下面的测试。</p>
<p>这段代码在我的浏览器中执行结果如下：</p>
<p><img src="http://img.heroicyang.com/setTimeout-Measure.png" alt=""></p>
<p>在我本地的<code>Nodejs</code>环境中执行结果如下：  </p>
<p><img src="http://img.heroicyang.com/setTimeout-Measure-Nodejs.png" alt="">  </p>
<p>上面的这个测试只是想说明<code>setTimeout(func, 0)</code>定时任务的回调函数执行时间是有延迟的，而并不是所谓的立即执行。  </p>
<p>因此，我们可以利用<code>setTimeout(func, 0)</code>来解决事件重叠所产生的负面效果，修正执行顺序。 </p>
<h3>奇巧淫技之一：模拟浏览器的事件捕获</h3>
<p>众所周知，浏览器的DOM事件都是采用冒泡的方式，只有个别浏览器是支持事件捕获的。而在实际的开发过程中可能存在需要事件捕获的需求，要求子元素的事件在父元素触发之后才能触发。为了兼容各个浏览器，我们不能使用事件捕获，而<code>setTimeout(func, 0)</code>在这个时候就很乐意帮忙了。  </p>
<p><figure class="highlight lang-javascript"><pre>&lt;input type=<span class="string">"button"</span> value=<span class="string">"click"</span> id=<span class="string">"cbtn"</span>&gt;
<span class="xml"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"result"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">
  <span class="keyword">var</span> cbtn = document.getElementById(<span class="string">'cbtn'</span>)
    , result = document.getElementById(<span class="string">'result'</span>);

  cbtn.onclick = <span class="keyword">function</span>(e) {
    setTimeout(<span class="keyword">function</span>() {
      result.innerHTML += <span class="string">'input click, '</span>;
    }, <span class="number">0</span>);
  };

  document.body.onclick = <span class="keyword">function</span>(e) {
    result.innerHTML += <span class="string">'body click -&gt; '</span>;
  };
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span>
</pre></figure><br>点击查看运行效果：  </p>
<iframe src="http://sample.heroicyang.com/setTimeout01.html" style="border: 1px solid #DDD; border-radius: 3px; background: #F8F8F8; width: 90%; height:80px; padding: 1px;"></iframe>

<h3>奇巧淫技之二：让浏览器更好的工作</h3>
<p>大多数情况下，我们可以在浏览器的默认行为之前对事件进行处理，但是有时我们按照常规的思路去做的时候，往往事与愿违。比如下面的例子。  </p>
<p><figure class="highlight lang-javascript"><pre>&lt;input type=<span class="string">"text"</span> id=<span class="string">"wordInput"</span>&gt;
<span class="xml"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">
  <span class="keyword">var</span> wordInput = document.getElementById(<span class="string">'wordInput'</span>);
  wordInput.onkeypress = <span class="keyword">function</span>(e) {
    <span class="keyword">this</span>.value = <span class="keyword">this</span>.value.toUpperCase();
  };
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span>
</pre></figure><br>看似一个很简单的需求：每输入一个字符，就将其转换为大写。但是上面的代码完全没有按照指示去做，不信你试试看：  </p>
<iframe src="http://sample.heroicyang.com/setTimeout-toUpper-01.html" style="border: 1px solid #DDD; border-radius: 3px; background: #F8F8F8; height:45px; padding: 1px;"></iframe>  

<p>如果没有下一次输入，文本框中的小写字母永远都不会转换为大写。Why? 因为浏览器在<code>keypress</code>事件处理的时候，还没有将我们输入的值添加到文本框。于是乎换一个事件来handle然后再处理吧，既然键按下的时候还木有值，那就等键弹起来之后再处理。  </p>
<p><figure class="highlight lang-javascript"><pre>&lt;input type=<span class="string">"text"</span> id=<span class="string">"wordInput"</span>&gt;
<span class="xml"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">
  <span class="keyword">var</span> wordInput = document.getElementById(<span class="string">'wordInput'</span>);
  wordInput.onkeyup = <span class="keyword">function</span>(e) {
    <span class="keyword">this</span>.value = <span class="keyword">this</span>.value.toUpperCase();
  };
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span>
</pre></figure><br>运行试试吧。</p>
<iframe src="http://sample.heroicyang.com/setTimeout-toUpper-02.html" style="border: 1px solid #DDD; border-radius: 3px; background: #F8F8F8; height:45px; padding: 1px;"></iframe>  

<p>大概似乎是可行了，可是仔细观察就看出问题了。<code>keyup</code>事件触发时，文本框已经具备完整的值了，但先是一个小写的值，键完全释放之后转变为大写。这不科学…这太丑陋...  </p>
<p>是时候关门放出<code>setTimeout(func, 0)</code>了。。。</p>
<p><figure class="highlight lang-javascript"><pre>&lt;input type=<span class="string">"text"</span> id=<span class="string">"wordInput"</span>&gt;
<span class="xml"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">
  <span class="keyword">var</span> wordInput = document.getElementById(<span class="string">'wordInput'</span>);
  wordInput.onkeypress = <span class="keyword">function</span>(e) {
    <span class="keyword">var</span> self = <span class="keyword">this</span>;
    setTimeout(<span class="keyword">function</span>() {
      self.value = self.value.toUpperCase();
    }, <span class="number">0</span>);
  };
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span>
</pre></figure>  </p>
<iframe src="http://sample.heroicyang.com/setTimeout-toUpper-03.html" style="border: 1px solid #DDD; border-radius: 3px; background: #F8F8F8; height:45px; padding: 1px;"></iframe>  

<p>已经完美了。<code>keypress</code>事件触发时，将转换大写的操作添加到事件队列，紧接着浏览器添加我们输入的值，然后近乎0延迟的执行我们的转换大写操作函数。  </p>
<p>上面两个小案例只是冰山一角，so...合理利用<code>setTimeout(func, 0)</code>，明天更美好！</p>
]]></content>
    <category scheme="http://heroicyang.com/tags/javascript/" term="javascript"/>
    <category scheme="http://heroicyang.com/tags/javascript-timer/" term="javascript timer"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[深入理解JavaScript定时器（续）]]></title>
    <link href="http://heroicyang.com/2012/10/14/javascript-timer-and-event-in-depth/"/>
    <id>http://heroicyang.com/2012/10/14/javascript-timer-and-event-in-depth/</id>
    <published>2012-10-14T14:50:00.000Z</published>
    <updated>2013-05-21T12:41:55.000Z</updated>
    <content type="html"><![CDATA[<p>对于浏览器端来说，大多数事件都是异步的，但是有部分事件却不是，这部分事件称做<strong>同步事件</strong>，因此它们都是立即执行的，完全不理会前几篇文章中所提到的<strong>事件队列</strong>。以及浏览器的渲染、重绘等操作，也会打乱之前我们好不容易所建立起来的<strong>事件队列</strong>的概念。不过，本篇将会陆续不断的把这些坑给填上。  </p>
<h2>同步事件</h2>
<h3>DOM改变事件(DOM Mutation events)</h3>
<p>下面的Demo便用于说明同步事件之一的<code>DOM Mutation events</code>（注：该事件不支持Chrome浏览器）。</p>
<figure class="highlight lang-html"><pre><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"http://heroicyang.com/"</span>&gt;</span>
  heroicyang.com
<span class="tag">&lt;/<span class="title">a</span>&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">
  <span class="keyword">var</span> anchor = document.getElementsByTagName(<span class="string">'a'</span>)[<span class="number">0</span>];
  anchor.onclick = <span class="keyword">function</span>(e) {
    alert(<span class="string">'in onclick'</span>);
    <span class="keyword">this</span>.setAttribute(<span class="string">'href'</span>, <span class="string">'#'</span>);
    alert(<span class="string">'out onclick'</span>);
    <span class="keyword">return</span> <span class="literal">false</span>;
  };
  <span class="keyword">if</span> (anchor.addEventListener) {  <span class="comment">//Firefox, Opera</span>
    anchor
      .addEventListener(<span class="string">'DOMAttrModified'</span>, onpropchange, <span class="literal">false</span>);
  } <span class="keyword">else</span> <span class="keyword">if</span> (anchor.attachEvent) {  <span class="comment">//IE</span>
    anchor
      .attachEvent(<span class="string">'onpropertychange'</span>, onpropchange);
  }
  
  <span class="function"><span class="keyword">function</span> <span class="title">onpropchange</span><span class="params">()</span> {</span>
    alert(<span class="string">'onpropchange'</span>);
  }
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</pre></figure>

<p><a name="more"></a>
当<code>click</code>事件触发时，其处理的顺序依次为：</p>
<ol>
<li>alert <code>in onclick</code>  </li>
<li>超链接的属性立即被改变，并alert <code>onpropchange</code>  </li>
<li>继续执行<code>onclick</code>事件处理程序中剩下的 <code>alert(&#39;out onclick&#39;);</code>  </li>
</ol>
<p><img src="http://img.heroicyang.com/synchronous-mutation-events.png" alt=""><br>关于<code>DOM Mutation events</code>，详情请参见：<br><a href="https://developer.mozilla.org/en-US/docs/DOM/Mutation_events"><a href="https://developer.mozilla.org/en-US/docs/DOM/Mutation_events">https://developer.mozilla.org/en-US/docs/DOM/Mutation_events</a></a><br><a href="http://www.w3.org/TR/DOM-Level-3-Events/#events-mutationevents"><a href="http://www.w3.org/TR/DOM-Level-3-Events/#events-mutationevents">http://www.w3.org/TR/DOM-Level-3-Events/#events-mutationevents</a></a>  </p>
<h3>嵌套的DOM事件</h3>
<p>在浏览器端，有一些方法会立即触发某类事件，而这类事件也是同步的。比如<code>element.focus()</code>，下面是演示代码。  </p>
<p><figure class="highlight lang-javascript"><pre>&lt;input type=<span class="string">"button"</span> value=<span class="string">"click me"</span>&gt;
<span class="xml"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span>&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">
  <span class="keyword">var</span> btn = document.getElementsByTagName(<span class="string">'input'</span>)[<span class="number">0</span>]
    , text = document.getElementsByTagName(<span class="string">'input'</span>)[<span class="number">1</span>];

  btn.onclick = <span class="keyword">function</span>(e) {
    console.log(<span class="string">'in onclick'</span>);
    text.focus();
    console.log(<span class="string">'out onclick'</span>);
  };

  text.onfocus = <span class="keyword">function</span>(e) {
    console.log(<span class="string">'onfocus'</span>);
  };
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span>
</pre></figure><br>执行结果如下：</p>
<p><img src="http://img.heroicyang.com/synchronous-focus-event.png" alt="">  </p>
<p>常规情况下，事件处理都是一个一个执行的，而我们也就假定一个事件开始时，前一个事件是执行完毕了的。而以上这些同步事件不仅打破了我们的常规认识，还会给我们带来一些负面效应。不过我们依旧可以使用<a href="http://heroicyang.com/2012/09/22/javascript-timer-in-depth.html">上一篇</a>中所使用的<code>setTimeout(func, 0)</code>来解决。  </p>
<h2>JavaScript执行与页面渲染</h2>
<p>大多数浏览器中，JavaScript的执行和页面渲染是互斥的，于是JavaScript执行时，浏览器就不会做任何的页面渲染。比如下面的Demo...  </p>
<p><figure class="highlight lang-javascript"><pre>&lt;!DOCTYPE HTML&gt;
<span class="xml"><span class="tag">&lt;<span class="title">html</span> <span class="attribute">lang</span>=<span class="value">"en-US"</span>&gt;</span>
<span class="tag">&lt;<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"UTF-8"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">title</span>&gt;</span>JavaScript执行与页面渲染<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
  <span class="tag">&lt;<span class="title">style</span> <span class="attribute">type</span>=<span class="value">"text/css"</span>&gt;</span><span class="css">
    <span class="id">#container</span> <span class="rules">{
      <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">200</span>px;</span></span> 
      <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100</span>px;</span></span> 
      <span class="rule"><span class="attribute">background-color</span>:<span class="value"> <span class="hexcolor">#A00000</span>;</span></span> 
      <span class="rule"><span class="attribute">margin-bottom</span>:<span class="value"> <span class="number">10</span>px;</span></span>
    <span class="rule">}</span></span>
  </span><span class="tag">&lt;/<span class="title">style</span>&gt;</span>
<span class="tag">&lt;/<span class="title">head</span>&gt;</span>
<span class="tag">&lt;<span class="title">body</span>&gt;</span>
  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"container"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
  <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"button"</span> <span class="attribute">value</span>=<span class="value">"run"</span> <span class="attribute">id</span>=<span class="value">"run"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">
    <span class="keyword">var</span> runBtn = document.getElementById(<span class="string">'run'</span>)
      , container = document.getElementById(<span class="string">'container'</span>);
    
    runBtn.onclick = <span class="keyword">function</span>(e) {
      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0xA00000</span>; i &lt; <span class="number">0xFFFFFF</span>; i++) {
        container.style.backgroundColor = <span class="string">'#'</span> + i.toString(<span class="number">16</span>);
      }
    };
  </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span></span>
</pre></figure></p>
<iframe src="http://sample.heroicyang.com/repaint.html" style="border: 1px solid #DDD; border-radius: 3px; background: #F8F8F8; width: 90%; height:150px; padding: 1px;"></iframe>

<p>运行上面的Demo后，大多数浏览器都会假死了，直到<code>container</code>的背景颜色变更为<code>#FFFFFF</code>后才恢复。而有的浏览器(如Firefox)还会弹出警告，告知JavaScript没有响应，是终止还是等待。但是Opera却能正常运行，并不断更改背景颜色。因此不同浏览器对页面渲染和JavaScript执行的实现方式是不一样的。  </p>
<p>关于这方面有很大的学问，还需要继续学习，慢慢摸索。So...这个就点到为止了。</p>
<h3>模式对话框的同步调用</h3>
<p>浏览器提供的如<code>alert</code>等的模式对话框是同步调用的，所以当这类对话框工作时，会停止<code>JavaScript线程</code>，当然如页面渲染等活动也将被冻结。继续下面的Demo…当运行代码下面的<code>iframe</code>中的进度条后，无论是点击<code>主窗体中的alert</code>按钮，还是点击<code>iframe中的alert</code>按钮，都会导致进度条挂起。  </p>
<p><input type="button" value="主窗体中的alert" onclick="alert('主窗体对话框');"></p>
<p><figure class="highlight lang-javascript"><pre>&lt;div id=<span class="string">"container"</span> style=<span class="string">"width: 0px; height: 20px; background-color: #A00000;"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"button"</span> <span class="attribute">value</span>=<span class="value">"run"</span> <span class="attribute">id</span>=<span class="value">"run"</span>&gt;</span>
<span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"button"</span> <span class="attribute">value</span>=<span class="value">"stop"</span> <span class="attribute">id</span>=<span class="value">"stop"</span>&gt;</span>
<span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"button"</span> <span class="attribute">value</span>=<span class="value">"iframe中的alert"</span> <span class="attribute">onclick</span>=<span class="value">"alert('iframe中的对话框');"</span>&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">
  <span class="keyword">var</span> runBtn = document.getElementById(<span class="string">'run'</span>)
    , stopBtn = document.getElementById(<span class="string">'stop'</span>)
    , container = document.getElementById(<span class="string">'container'</span>);
  <span class="keyword">var</span> timer = <span class="literal">null</span>;

  runBtn.onclick = <span class="keyword">function</span>(e) {
    timer = setInterval(<span class="keyword">function</span>() {
      <span class="keyword">var</span> style = container.style;
      style.width = (parseInt(style.width) + <span class="number">2</span>) % <span class="number">400</span> + <span class="string">'px'</span>;
    }, <span class="number">50</span>);
  };
  stopBtn.onclick = <span class="keyword">function</span>(e) {
    clearInterval(timer);
  };
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span>
</pre></figure></p>
<iframe src="http://sample.heroicyang.com/modal-sync.html" style="border: 1px solid #DDD; border-radius: 3px; background: #F8F8F8; width: 90%; height:70px; padding: 1px;"></iframe>  

<p>因此，浏览器所提供的<code>alert</code>、<code>confirm</code>、<code>prompt</code>这三类模式对话框，都会阻塞<code>JavaScript线程</code>和<code>UI线程</code>。  </p>
<p><strong>依旧，Opera有一点点的例外。。。</strong>  </p>
<p>在Opera中，点击<code>主窗体中的alert</code>按钮不会阻塞<code>iframe</code>中的进度条。。。又打破我们的常规认识啊：同一个页面上，<code>iframe</code>是和主窗体同一个线程的。但Opera的设计并非如此。。。  </p>
<h2>当脚本需要花很长的时间干复杂的工作时</h2>
<p>类似的就是前面那个阻塞我们浏览器的，频繁更改<code>container</code>背景颜色的例子。最后，我们还是用<a href="http://heroicyang.com/2012/09/22/javascript-timer-in-depth.html">上一篇文章中</a>的<code>setTimeout(func, 0)</code>来解决它吧。  </p>
<p><figure class="highlight lang-javascript"><pre>&lt;div id=<span class="string">"container"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"button"</span> <span class="attribute">value</span>=<span class="value">"run"</span> <span class="attribute">id</span>=<span class="value">"run"</span>&gt;</span>
<span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"button"</span> <span class="attribute">value</span>=<span class="value">"stop"</span> <span class="attribute">id</span>=<span class="value">"stop"</span>&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">
  <span class="keyword">var</span> runBtn = document.getElementById(<span class="string">'run'</span>)
    , stopBtn = document.getElementById(<span class="string">'stop'</span>)
    , container = document.getElementById(<span class="string">'container'</span>);
  <span class="keyword">var</span> i = <span class="number">0xA00000</span>, timer = <span class="literal">null</span>;

  runBtn.onclick = <span class="keyword">function</span>(e) {
    <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span> {</span>
      timer = setTimeout(run, <span class="number">0</span>);
      container.style.backgroundColor = <span class="string">'#'</span> + i.toString(<span class="number">16</span>);

      <span class="keyword">if</span> (i++ == <span class="number">0xFFFFFF</span>) stop();
    }
    timer = setTimeout(run, <span class="number">0</span>);
  };
  stopBtn.onclick = stop;

  <span class="function"><span class="keyword">function</span> <span class="title">stop</span><span class="params">()</span> {</span>
    clearTimeout(timer);
  }
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span>
</pre></figure></p>
<iframe src="http://sample.heroicyang.com/heavy-jobs.html" style="border: 1px solid #DDD; border-radius: 3px; background: #F8F8F8; width: 90%; height:150px; padding: 1px;"></iframe>  

<p>最后，总结一下<code>setTimeout(func, 0)</code>的使用场景吧：</p>
<ol>
<li>让浏览器渲染当前的变化  </li>
<li>避免长时间运行的脚本  </li>
<li>流程控制  </li>
<li>等等等等。。。</li>
</ol>
]]></content>
    <category scheme="http://heroicyang.com/tags/javascript/" term="javascript"/>
    <category scheme="http://heroicyang.com/tags/javascript-timer/" term="javascript timer"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[《JavaScript设计模式》阅读笔记]]></title>
    <link href="http://heroicyang.com/2013/03/26/javascript-design-pattern-notes/"/>
    <id>http://heroicyang.com/2013/03/26/javascript-design-pattern-notes/</id>
    <published>2013-03-26T15:42:35.000Z</published>
    <updated>2013-05-21T14:01:51.000Z</updated>
    <content type="html"><![CDATA[<p>最近总算是把《JavaScript设计模式》这本书给认认真真啃完了，受益匪浅。虽然已经是几年前的出版物了，而且也没得地方可以买到，但是我个人觉得这本书是JavaScript程序员必读书籍之一。如果没有读过，建议一读，绝对不会让你失望。  </p>
<p>而可能有一些地方的翻译让人一开始有点迷糊，比如我们常说的“单例模式”被译为“单体模式”，而“mixin class”被译为“掺元类”。但是对于我这种E文能力弱的人来说，完全没有挑剔的地方。  </p>
<p>我在读这本书的时候，采取了一些阅读方式来加深理解，个人感觉还过得去，就简单的分享下。我每两天完成一章节，第一天阅读整个章节的内容，边理解边对照着写实例代码；之后若是一有时间，大脑就温习这次的内容；第二天则主动回忆前一天所阅读的内容，整理简要的笔记纲要，并按照个人的理解和笔记纲要再写一次实例代码。  </p>
<p>因此这本书读完之后，我的笔记也就随即产出了。我没有采用很长的篇幅记录，而是思维导图来整理每一章的内容，这样也方便日后温习。  </p>
<p>呃，好久也没有写博客了，所以将笔记也一并分享出来，也欢迎大家分享自己的学习方法和笔记方法。<br><a name="more"></a>  </p>
<p><a href="http://cl.ly/3p383r2V1M0Z">我将思维导图导出成pdf版本了，需要的自取吧！</a>  </p>
<p>顺便也放张预览图，不过有点大。</p>
<p><img src="http://img.heroicyang.com/JavaScript-Design-Pattern-Notes.png" alt="《JavaScript设计模式》读书笔记"></p>
]]></content>
    <category scheme="http://heroicyang.com/tags/javascript/" term="javascript"/>
    <category scheme="http://heroicyang.com/tags/design-pattern/" term="design pattern"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[折腾了个新主题]]></title>
    <link href="http://heroicyang.com/2013/05/22/hexo-theme-modernist/"/>
    <id>http://heroicyang.com/2013/05/22/hexo-theme-modernist/</id>
    <published>2013-05-22T15:36:51.000Z</published>
    <updated>2013-06-02T16:11:36.000Z</updated>
    <content type="html"><![CDATA[<p>前几天偶然发现了一个Github Page主题：<a href="http://orderedlist.github.io/modernist/">Modernist</a>，觉着很舒服。作者将其开源在Github上的，所以我就fork下来自己折腾了个<a href="https://github.com/tommy351/hexo">Hexo</a>的主题。  </p>
<p>根据<a href="https://github.com/tommy351/hexo-theme-light">light</a>主题的结构修改而来，但是去掉了侧边栏，改成一栏，所以随之也就没有了light主题的那些widget了。不过我增加了国内的<a href="http://duoshuo.com/">多说评论框</a>的配置，以及更好的响应式支持。  </p>
<p>主题已经放到<a href="https://github.com/heroicyang/hexo-theme-modernist">Github</a>上了，也已完全适用于最新版的Hexo。<span class="text-lt">为了更好的使用这个主题，建议clone我fork的<a href="https://github.com/heroicyang/hexo">hexo</a>项目到本地，使用<code>/path/to/hexo/bin/hexo</code>来代替之前安装的全局<code>hexo</code>命令，方法见下面。我主要修改了代码块高亮（highlight）生成，以及修复了始终会生成Read more链接的BUG，不过我会尽快发起pull request到hexo的。</span>  </p>
<p>另外，如果需要使用多说评论框，可以使用我的自定义多说评论框样式，主要保持了和Modernist theme的样式统一。请猛戳<a href="https://gist.github.com/heroicyang/5644407">这里</a>。</p>
]]></content>
    <category scheme="http://heroicyang.com/tags/hexo/" term="hexo"/>
    <category scheme="http://heroicyang.com/tags/theme/" term="theme"/>
    <category scheme="http://heroicyang.com/tags/modernist/" term="modernist"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[关于JavaScript中的继承（一）：类式继承]]></title>
    <link href="http://heroicyang.com/2013/05/30/learn-javascript-inherit-class/"/>
    <id>http://heroicyang.com/2013/05/30/learn-javascript-inherit-class/</id>
    <published>2013-05-30T14:19:21.000Z</published>
    <updated>2013-05-30T16:56:42.000Z</updated>
    <content type="html"><![CDATA[<p>“继承”是面向对象中的一个概念，说开去无非就是代码重用的一种方式罢了。  </p>
<p>虽然JavaScript并不是一门真正的面向对象语言，甚至连类的概念都没有。但得益于构造器的存在，在JavaScript中是可以完全模拟出 <strong>类-对象</strong> 行为的。如：  </p>
<figure class="highlight lang-javascript"><pre><span class="keyword">var</span> person = <span class="keyword">new</span> Person();
</pre></figure>

<p>看上去除了变量声明时不是强类型之外，完全与面向对象如出一辙。所以谈及继承时，大家首推的也是一种叫“类式继承”的手法了。  </p>
<h3>类式继承之基于原型链</h3>
<figure class="highlight lang-javascript"><pre><span class="keyword">var</span> Parent = <span class="function"><span class="keyword">function</span> <span class="params">(name)</span> {</span>
  <span class="keyword">this</span>.name = name || <span class="string">'heroic'</span>;
};
Parent.prototype.printName = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  console.log(<span class="keyword">this</span>.name);
};
<span class="keyword">var</span> Child = <span class="function"><span class="keyword">function</span> <span class="params">(name)</span> {</span>};

inherit(Child, Parent);
<span class="comment">// or</span>
Child.inherit(Parent);
</pre></figure>

<a name="more"></a>

<p>上面的伪代码是类式继承的理想状态，但<code>inherit</code>方法并不存在，需要由自己实现。  </p>
<figure class="highlight lang-javascript"><pre><span class="keyword">var</span> inherit = <span class="function"><span class="keyword">function</span> <span class="params">(subClass, superClass)</span> {</span>
  subClass.prototype = <span class="keyword">new</span> superClass();
};
<span class="comment">// 为了实现 Child.inherit(Parent) 这样的效果</span>
Function.prototype.inherit = <span class="function"><span class="keyword">function</span> <span class="params">(superClass)</span> {</span>
  <span class="keyword">this</span>.prototype = <span class="keyword">new</span> superClass();
};
</pre></figure>

<p>和计划中的一样，子对象不仅继承了父对象的属性，也继承了父对象原型上的方法。  </p>
<figure class="highlight lang-javascript"><pre><span class="keyword">var</span> child = <span class="keyword">new</span> Child();
child.name = <span class="string">'test'</span>;
child.printName();  <span class="comment">// 'test'</span>
</pre></figure>

<p>但是这种方式却存在一些问题：</p>
<ol>
<li>对象属性的写操作是直接发生的，即对象如果不存在这个属性，则为该对象创建这个属性，并为其赋值；如果存在，则直接为其赋新值。而对于对象属性的读操作，则完全不一样了：首先查找对象本身是否有该属性，有则返回，没有则查找其原型链，直到找到该属性为止，如果到了原型链的最顶层(Object)都没找到，则返回<code>undefined</code>。由于存在这种读写的不对等性，我们都不会采取从父对象继承属性，而是直接为子对象添加属性即可，而需要继承的方法则放到原型上。</li>
<li>且上面的实现中，我们无法完成这样的初始化：<code>var child = new Child(&#39;test&#39;)</code>  </li>
</ol>
<p>利用原型链实现的类式继承先放一边，为了解决在初始化就能传入参数的问题，便产生了一种叫“借用构造函数”方式的继承。  </p>
<h3>类式继承之借用构造函数</h3>
<figure class="highlight lang-javascript"><pre><span class="keyword">var</span> Parent = <span class="function"><span class="keyword">function</span> <span class="params">(name)</span> {</span>
  <span class="keyword">this</span>.name = name || <span class="string">'heroic'</span>;
  <span class="keyword">this</span>.printName = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    console.log(<span class="keyword">this</span>.name);
  };
}

<span class="keyword">var</span> Child = <span class="function"><span class="keyword">function</span> <span class="params">(name)</span> {</span>
  Parent.call(<span class="keyword">this</span>, name);
  <span class="comment">// 或者在多参数的情况下</span>
  <span class="comment">// Parent.apply(this, arguments);</span>
}

<span class="keyword">var</span> child = <span class="keyword">new</span> Child(<span class="string">'test'</span>);
child.printName();  <span class="comment">// 'test'</span>

<span class="keyword">var</span> parent = <span class="keyword">new</span> Parent();
parent.printName();  <span class="comment">// 'heroic'</span>
</pre></figure>

<p>首先来谈谈这种机制相对于第一种的优点，Talk is cheap, Show me the code.  </p>
<figure class="highlight lang-javascript"><pre><span class="keyword">var</span> Parent = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">this</span>.tags = [<span class="string">'.NETer'</span>];
}
<span class="keyword">var</span> parent = <span class="keyword">new</span> Parent();

<span class="keyword">var</span> ChildA = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>};
ChildA.prototype = parent;

<span class="keyword">var</span> ChildB = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  Parent.apply(<span class="keyword">this</span>, arguments);
};

<span class="keyword">var</span> child_a = <span class="keyword">new</span> ChildA();
child_a.tags.push(<span class="string">'Javaer'</span>);

<span class="keyword">var</span> child_b = <span class="keyword">new</span> ChildB();
child_b.tags.push(<span class="string">'Pythoner'</span>);

console.log(child_a.tags.join(<span class="string">', '</span>));  <span class="comment">//.NETer, Javaer</span>
console.log(child_b.tags.join(<span class="string">', '</span>));  <span class="comment">//.NETer, Pythoner</span>

console.log(parent.tags.join(<span class="string">', '</span>));  <span class="comment">//.NETer, Javaer</span>
<span class="comment">// WTF...Why is my tags contains `Javaer` ?</span>
</pre></figure>

<p>显而易见，借用构造函数方式在继承时是采取一份单独的拷贝，而原型链方式则是指向同一个引用。（但是由此可见，原型链上的属性或方法不会在每个实例中都创建一次。）  </p>
<p>接下来则是谈谈缺陷了。</p>
<figure class="highlight lang-javascript"><pre><span class="keyword">var</span> Parent = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>};
Parent.prototype.papapa = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  console.log(<span class="string">'pa pa pa...'</span>);
};

<span class="keyword">var</span> Child = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  Parent.apply(<span class="keyword">this</span>, arguments);
};

<span class="keyword">var</span> child = <span class="keyword">new</span> Child();
child.papapa();  <span class="comment">// TypeError: Object [object Object] has no method 'papapa'</span>
<span class="comment">// Yeah, you're too young, so...</span>
</pre></figure>

<p>借用构造函数其实是在构造时，通过改写方法调用上下文来实现属性的拷贝，所以并未涉及到<code>prototype</code>，所以就没有办法继承原型了。  </p>
<p>由于原型链上的属性或方法不会在每个实例中都创建一次，所以是我们放置需要重用的属性和方法的理想地方；而借用构造函数则可以使子对象拥有自己一份独立的拷贝，不存在意外改写父对象属性的风险。所以两者互补产生了第三种比较完美的继承方式。  </p>
<h3>类式继承之组合模式</h3>
<figure class="highlight lang-javascript"><pre><span class="keyword">var</span> Parent = <span class="function"><span class="keyword">function</span> <span class="params">(name)</span> {</span>
  <span class="keyword">this</span>.name = name || <span class="string">'heroic'</span>;
  <span class="keyword">this</span>.tags = [<span class="string">'coder'</span>];
};
Parent.prototype.print = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  console.log(<span class="string">'name: '</span>, <span class="keyword">this</span>.name, <span class="string">', tags: '</span>, <span class="keyword">this</span>.tags.join(<span class="string">', '</span>));
};

<span class="keyword">var</span> parent = <span class="keyword">new</span> Parent();

<span class="keyword">var</span> Child = <span class="function"><span class="keyword">function</span> <span class="params">(name)</span> {</span>
  Parent.apply(<span class="keyword">this</span>, arguments);
};
Child.prototype = parent;

<span class="keyword">var</span> child = <span class="keyword">new</span> Child(<span class="string">'test'</span>);
child.tags.push(<span class="string">'player'</span>);

child.print();  <span class="comment">// name:  test , tags:  coder, player</span>
parent.print();  <span class="comment">// name:  heroic , tags:  coder</span>
</pre></figure>

<p>近乎完美的实现，子对象继承了父对象的成员，但拥有自己的一份拷贝，不会担心修改自己而影响到父对象；子对象也复用了父对象原型中的方法；且子对象也可以传递任意参数给父对象的构造函数。可谓是面向对象中“类式继承”的准确诠释。</p>
]]></content>
    <category scheme="http://heroicyang.com/tags/javascript/" term="javascript"/>
    <category scheme="http://heroicyang.com/tags/inherit/" term="inherit"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[关于JavaScript中的继承（二）：原型式继承]]></title>
    <link href="http://heroicyang.com/2013/06/02/learn-javascript-inherit-proto/"/>
    <id>http://heroicyang.com/2013/06/02/learn-javascript-inherit-proto/</id>
    <published>2013-06-02T14:52:19.000Z</published>
    <updated>2013-06-02T16:19:06.000Z</updated>
    <content type="html"><![CDATA[<p>JavaScript中本没有类，所以凡事也不要强求，强扭的瓜总是不填的嘛。继承也无非就是一个对象拥有另外一个对象的特性，所以完全不需要复杂的去模拟面向对象中的类式继承，而借助JavaScript独特的原型机制就可以实现了。同样，需要创建一个对象时也不再采用模拟<strong>类-对象</strong>的方式，而是直接使用JavaScript的对象字面量就好了。因为对于对象来说我们关系的无非也就是它具备哪些属性、有哪些行为而已。  </p>
<figure class="highlight lang-javascript"><pre><span class="keyword">var</span> parent = {
  printName: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    console.log(<span class="keyword">this</span>.name || <span class="string">'parent'</span>);
  }
};

<span class="keyword">var</span> child = {};  <span class="comment">// 暂时这样</span>
child.name = <span class="string">'child'</span>;  <span class="comment">// 在很多情况下我们并不希望继承原对象自己的属性，而是在我们需要时，直接添加就好</span>
child.printName();  <span class="comment">// 重点的是我们希望child具备打印自己名字的行为</span>
</pre></figure>

<p>上面的代码目前还不能工作，<a href="http://heroicyang.com/2013/05/30/learn-javascript-inherit-class/">上一篇文章</a>中谈到过JavaScript中对象属性查找机制，如果<code>child</code>对象本身没有<code>printName()</code>这个方法，那我们保证其原型上有这个方法，它就能正常工作了。  </p>
<figure class="highlight lang-javascript"><pre><span class="comment">/* var parent... */</span>

<span class="keyword">var</span> object = <span class="function"><span class="keyword">function</span> <span class="params">(obj)</span> {</span>
  <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>};
  F.prototype = obj;
  <span class="keyword">return</span> <span class="keyword">new</span> F;
};

<span class="comment">// 改变child对象的创建方式，不直接采用字面量了，而是用`object`方法来创建</span>
<span class="keyword">var</span> child = object(parent);
child.name = <span class="string">'child'</span>;
child.printName();  <span class="comment">// 'child'</span>
</pre></figure>

<p>通过一个<code>object()</code>函数，我们就完全可以实现一个对象从另一个对象继承了。其原理很简单，即在<code>object()</code>函数内部创建一个临时的构造函数，然后修改这个构造函数的原型，最后再返回这个构造函数的一个实例。</p>
<a name="more"></a>

<p>当然，<code>parent</code>对象也并不一定要使用对象字面量，你可以选择任何你能想到的创建对象的方式，如构造函数等。  </p>
<figure class="highlight lang-javascript"><pre><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> <span class="params">()</span> {</span>
  <span class="keyword">this</span>.name = <span class="string">'parent'</span>;
};
Parent.prototype.printName = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  console.log(<span class="keyword">this</span>.name);
};

<span class="keyword">var</span> parent = <span class="keyword">new</span> Parent();
<span class="keyword">var</span> child = object(parent);
child.printName();  <span class="comment">// 'parent'</span>
</pre></figure>

<p>正如前面所述，我们可能并不想继承原对象自己的属性，如上面的例子我们也并不希望它打印出<code>parent</code>。  </p>
<p>原型式继承的规则就是：对象从对象继承，不管父对象是如何而来。而<code>Parent.prototype</code>也是一个对象，所以  </p>
<figure class="highlight lang-javascript"><pre><span class="keyword">var</span> child = object(Parent.prototype);
child.printName();  <span class="comment">// undefined</span>
</pre></figure>

<p>改写之后，打印<code>child</code>自己的名字时得到的是<code>undefined</code>，因为创建<code>child</code>对象后，还没有给它赋予任何的属性，所以这恰是我们想要的结果。  </p>
<p>而在<code>ECMAScript 5</code>中，原型式继承已经成为了语言特性，为我们增加了<code>Object.create()</code>方法，也就是说可以不用自己实现上面的<code>object</code>方法了。而且<code>Object.create()</code>方法更加强劲、适用。  </p>
<figure class="highlight lang-javascript"><pre><span class="keyword">var</span> parent = {
  name: <span class="string">'parent'</span>,
  printName: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    console.log(<span class="keyword">this</span>.name);
  }
};

<span class="comment">// 第二个参数接收一个对象，而该对象的属性将作为`child`对象的属性</span>
<span class="keyword">var</span> child = Object.create(parent, {
  name: { value: <span class="string">'child'</span> }
});

child.printName();  <span class="comment">// 'child'</span>
</pre></figure>

<p>最后，再谈谈最开始实现的<code>object()</code>方法吧，其实还可以做一点点简单的优化。那就是每次调用<code>object()</code>方法时都要创建一个临时的代理构造函数<code>F</code>，而事实上仅需要创建一次就足够了。  </p>
<figure class="highlight lang-javascript"><pre><span class="keyword">var</span> object = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>};
  
  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(obj)</span> {</span>
    F.prototype = obj;
    <span class="keyword">return</span> <span class="keyword">new</span> F;  
  };
}();
</pre></figure>

<p>我们把代理构造函数放到一个立即执行的函数中创建，然后这个函数返回一个新的、真正实现继承逻辑的函数。</p>
]]></content>
    <category scheme="http://heroicyang.com/tags/javascript/" term="javascript"/>
    <category scheme="http://heroicyang.com/tags/inherit/" term="inherit"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[关于JavaScript中的继承（三）：再谈类式继承]]></title>
    <link href="http://heroicyang.com/2013/06/07/javascript-class-inherit-optimized/"/>
    <id>http://heroicyang.com/2013/06/07/javascript-class-inherit-optimized/</id>
    <published>2013-06-07T14:23:30.000Z</published>
    <updated>2013-06-07T15:42:06.000Z</updated>
    <content type="html"><![CDATA[<p>在<a href="/2013/05/30/learn-javascript-inherit-class/">《关于JavaScript中的继承（一）：类式继承》</a>中已经基本上实现了类式继承，但仍然还存在一些问题，接下来对之前的实现进一步进行完善。  </p>
<figure class="highlight lang-javascript"><pre><span class="keyword">var</span> Parent = <span class="function"><span class="keyword">function</span> <span class="params">(name)</span> {</span>
  <span class="keyword">this</span>.name = name || <span class="string">'heroic'</span>;
};
Parent.prototype.print = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  console.log(<span class="string">'name: '</span>, <span class="keyword">this</span>.name);
};

<span class="keyword">var</span> parent = <span class="keyword">new</span> Parent();

<span class="keyword">var</span> Child = <span class="function"><span class="keyword">function</span> <span class="params">(name)</span> {</span>
  Parent.apply(<span class="keyword">this</span>, arguments);
};
Child.prototype = parent;
Child.prototype.setChildAge = <span class="function"><span class="keyword">function</span> <span class="params">(age)</span> {</span>
  <span class="keyword">this</span>.age = age;
};

parent.setChildAge(<span class="number">10</span>);
console.log(parent.age);  <span class="comment">// 10</span>
</pre></figure>

<p>正如代码所见，在为子对象原型添加自己独有方法的时候，父对象也受到了影响，这可不是期望的结果。  </p>
<figure class="highlight lang-javascript"><pre><span class="keyword">var</span> child = <span class="keyword">new</span> Child(<span class="string">'child'</span>);
console.log(child.name);  <span class="comment">// 'child'</span>

<span class="keyword">delete</span> child.name;
console.log(child.name);  <span class="comment">// 'heroic'</span>
</pre></figure>

<p>同样如代码所示，<code>child</code>对象持有了两个<code>name</code>属性，一个是通过构造函数拷贝的，另一个是原型链上的，当删除掉本身的<code>name</code>属性后，便访问到了原型链上的了。对于这个问题，解决方案很简单直接：  </p>
<figure class="highlight lang-javascript"><pre><span class="comment">/* ... */</span>
Child.prototype = Parent.prototype;  <span class="comment">// 只继承父对象原型链上的属性</span>
<span class="comment">/* ... */</span>
<span class="keyword">delete</span> child.name;
console.log(child.name);  <span class="comment">// undefined</span>
</pre></figure>

<p>但是这种方法也并没有解决最开始的那个问题，即添加或删除子对象原型上的属性时，会一并反映到父对象中。这个时候就需要用到<a href="/2013/06/02/learn-javascript-inherit-proto/">《关于JavaScript中的继承（二）：原型式继承》</a>中用到的临时构造函数了。  </p>
<a name="more"></a>

<figure class="highlight lang-javascript"><pre><span class="keyword">var</span> inherit = <span class="function"><span class="keyword">function</span> <span class="params">(subClass, superClass)</span> {</span>
  <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>};
  F.prototype = superClass.prototype;
  subClass.prototype = <span class="keyword">new</span> F;
};

<span class="comment">// 然后将 `Child.prototype = Parent.prototype` 调整为</span>
inherit(Child, Parent);

<span class="comment">// 增加`Child`自己的方法之后</span>
Child.prototype.setChildAge = <span class="function"><span class="keyword">function</span> <span class="params">(age)</span> {</span>
  <span class="keyword">this</span>.age = age;
};

parent.setChildAge(<span class="number">10</span>);  <span class="comment">// TypeError: Object [object Object] has no method 'setChildAge'</span>
</pre></figure>

<p>不再影响父对象的行为了，而且还可以为<code>inherit</code>方法增加子对象访问父对象行为的特性。  </p>
<figure class="highlight lang-javascript"><pre><span class="keyword">var</span> inherit = <span class="function"><span class="keyword">function</span> <span class="params">(subClass, superClass)</span> {</span>
  <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>};
  F.prototype = superClass.prototype;
  subClass.prototype = <span class="keyword">new</span> F;
  subClass.prototype._super = superClass.prototype;
};

<span class="comment">// 然后重写了子对象的`print()`方法，但依然还是想重用父对象的</span>
Child.prototype.print = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  console.log(<span class="string">'before print...balabala...'</span>);
  <span class="keyword">this</span>._super.print.call(<span class="keyword">this</span>);
};

<span class="keyword">var</span> child = <span class="keyword">new</span> Child(<span class="string">'child'</span>);
child.print();  <span class="comment">// 'before print...balabala...'</span>
                <span class="comment">// 'name:  child'</span>
</pre></figure>

<p>最后，如果说这个类式继承模式还有哪点不够完美的话，那就是在子对象继承父对象之后，子对象的构造函数指向被改写了。  </p>
<figure class="highlight lang-javascript"><pre>console.log(child.constructor === Parent);  <span class="comment">// true</span>
</pre></figure>

<p>没办法，只有在继承的最后，把<code>constructor</code>修正回来就是。  </p>
<figure class="highlight lang-javascript"><pre><span class="keyword">var</span> inherit = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>};

  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(subClass, superClass)</span> {</span>
    F.prototype = superClass.prototype;
    subClass.prototype = <span class="keyword">new</span> F;
    subClass.prototype._super = superClass.prototype;
    subClass.prototype.constructor = subClass;
  };
}();

<span class="comment">/* ... */</span>
console.log(child.constructor === Child);  <span class="comment">// true</span>
console.log(child.constructor === Parent);  <span class="comment">// false</span>
</pre></figure>

<p>同时，也如<a href="/2013/06/02/learn-javascript-inherit-proto/">《关于JavaScript中的继承（二）：原型式继承》</a>中提到的那样，利用闭包来减少每次调用<code>inherit()</code>都会生成一个临时构造函数的开销。  </p>
<p>写在最后，类式继承为我们带来了JavaScript中不存在的完整的类的概念，这对于从面向对象语言转过来的程序员来说，可能是很好的方式。但是它也有可能让我们忽略了JavaScript真正的原型式继承。不过这些模式都没有好与坏之分，应该在适合的场景使用合适的方法才是。</p>
]]></content>
    <category scheme="http://heroicyang.com/tags/javascript/" term="javascript"/>
    <category scheme="http://heroicyang.com/tags/inherit/" term="inherit"/>
  </entry>
</feed>
